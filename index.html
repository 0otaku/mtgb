<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>みんなでブラケット診断</title>

<link rel="preconnect" href="https://esm.sh" crossorigin>
<link rel="preconnect" href="https://www.hareruyamtg.com" crossorigin>
<link rel="dns-prefetch" href="//www.hareruyamtg.com">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 16 16%27><circle cx=%278%27 cy=%278%27 r=%273%27/></svg>">

<style>
:root{
  --bg:#fff; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb;
  --brand:#d62828; --c1:#6EE7B7; --c2:#93C5FD; --c3:#FDE68A; --c4:#FCA5A5;
  --radius:14px; --accent:#6366f1; --accent2:#8b5cf6;
}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;font-family:"Inter","Noto Sans JP",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--fg);background:var(--bg)}
.wrap{max-width:1200px;margin:0 auto;padding:16px}

/* header */
header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px 0 12px}
.title{display:flex;flex-direction:column;gap:4px;min-width:0}
.site{font-weight:800;letter-spacing:.01em;font-size:20px}
@media(min-width:1000px){ .site{font-size:24px} }
.deck-meta{display:flex;align-items:center;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:13px}
.deck-link{color:#2563eb;text-decoration:underline;text-underline-offset:2px}

/* デッキタグ（タイトル右） */
.tag-chips{display:inline-flex;gap:6px;flex-wrap:wrap}
.tagchip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:#fff;color:#374151;font-size:12px;white-space:nowrap}
.tagchip.theme{border-color:#c7d2fe;background:#eef2ff}
.tagchip.free{border-color:#e5e7eb;background:#f9fafb}

/* 汎用ボタン */
.small-btn{font-size:13px;border:1px solid var(--border);background:#fff;color:#374151;border-radius:999px;padding:6px 12px;cursor:pointer}
.small-btn:hover{background:#fafafa}
.small-btn.primary{background:#111;border-color:#111;color:#fff}
.small-btn.subtle{opacity:.82}
.small-btn.subtle:hover{opacity:1}

.card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.grid{display:grid;gap:16px}
@media(min-width:1000px){ .grid{grid-template-columns:1.2fr .8fr} }

/* 埋め込み */
.embed-wrap{position:relative;background:#fff;border-radius:var(--radius);overflow:hidden;border:1px solid var(--border)}
iframe{width:100%;height:70vh;min-height:520px;border:0;display:block;background:#fff}
.overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(255,255,255,.94), rgba(255,255,255,.94));text-align:center;padding:18px}
.overlay .box{max-width:560px}
.overlay .box h3{margin:0 0 8px;font-size:18px}
.overlay .box p{margin:6px 0;color:#4b5563;font-size:14px}
.overlay .box .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
.overlay .box a, .overlay .box button{border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#fff;cursor:pointer;font-size:14px}

/* 投票 */
.vote-card{display:flex;flex-direction:column;gap:12px}
.vote-block{padding:12px;border:1px dashed var(--border);border-radius:14px;background:#fafafa}
.prompt{font-weight:800;letter-spacing:.01em;font-size:16px}
@media(min-width:1000px){ .prompt{font-size:20px} }
.vote-row{display:grid; gap:10px; grid-template-columns:1fr 1fr; margin-top:10px}
@media(min-width:1000px){ .vote-row{grid-template-columns:repeat(4,1fr)} }
.chip{width:100%; height:64px; font-size:22px; font-weight:800; border:1px solid var(--border); border-radius:12px; background:#f4f4f5; cursor:pointer; transition:transform .07s ease, background .15s ease, box-shadow .15s ease;}
.chip:hover{background:#e9e9eb}
.chip:active{transform:scale(.98)}
.b1{background:color-mix(in srgb, var(--c1) 18%, white)}
.b2{background:color-mix(in srgb, var(--c2) 18%, white)}
.b3{background:color-mix(in srgb, var(--c3) 20%, white)}
.b4{background:color-mix(in srgb, var(--c4) 20%, white)}
@media(min-width:1000px){ .chip{height:72px; font-size:24px} }
.chip.selected{ position:relative; outline:2px solid var(--brand); box-shadow:0 0 0 4px color-mix(in srgb, var(--brand) 18%, transparent) inset; transform: translateY(-1px); filter:brightness(1.03) }
.chip[disabled]{opacity:.6; pointer-events:none; filter:grayscale(.2)}

.skip-row{margin-top:6px}
.skip{font-size:12px;color:#6b7280;text-decoration:underline;background:transparent;border:0;cursor:pointer}

/* 集計バー */
.results{display:none;flex-direction:column;gap:8px}
.bar{position:relative;height:30px;border-radius:8px;background:#f3f4f6;border:1px solid #e5e7eb;overflow:hidden}
.seg{position:absolute;top:0;bottom:0}
.seg.b1{background:var(--c1)} .seg.b2{background:var(--c2)} .seg.b3{background:var(--c3)} .seg.b4{background:var(--c4)}
.legend{display:flex;gap:10px;flex-wrap:wrap;color:#374151;font-size:13px}
.legend span{display:inline-flex;align-items:center;gap:6px}
.dot{width:12px;height:12px;border-radius:999px;display:inline-block}
.hint{font-size:12px;color:var(--muted)}

.action-row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
#nextBtn{ font-weight:700; border:1px solid var(--accent); background:linear-gradient(135deg, var(--accent), var(--accent2)); color:#fff; border-radius:10px; padding:8px 12px }
#nextBtn:hover{ filter:brightness(1.03) }
#nextBtn.pulse{ animation:nextPulse 1.8s ease-in-out infinite }
@keyframes nextPulse{ 0%{box-shadow:0 0 0 0 rgba(99,102,241,.45)} 70%{box-shadow:0 0 0 12px rgba(99,102,241,0)} 100%{box-shadow:0 0 0 0 rgba(99,102,241,0)} }

/* 理由チップ（Nextの下に10秒だけ） */
.reason-wrap{display:none;gap:6px;flex-wrap:wrap;margin-top:6px}
.reason-btn{font-size:12px;line-height:1;border:1px solid var(--border);border-radius:999px;padding:6px 8px;background:#fff;cursor:pointer}
.reason-btn.on{background:#111;color:#fff;border-color:#111}

/* 検索 */
.search-card{display:flex;flex-direction:column;gap:12px}
.search-row{display:flex;gap:8px;flex-wrap:nowrap}
input[type="text"]{flex:1 1 420px; min-width:260px; padding:10px 12px; border:1px solid var(--border); border-radius:10px; font-size:14px}
#searchBtn{padding:8px 12px}

/* Mana/XP */
.mana-wrap{display:flex;align-items:center;gap:8px;margin-top:6px}
.mana-bar{flex:1;height:6px;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;overflow:hidden}
.mana-bar > i{display:block;height:100%;width:0;background:#d1d5db}
.mana-syms{display:flex;align-items:center;gap:4px;flex-wrap:wrap}
.sym{width:16px;height:16px;border-radius:999px;border:1px solid #e5e7eb;display:inline-flex;align-items:center;justify-content:center;font-size:11px;line-height:1;background:#fff}
.sym.W{background:#fefce8;border-color:#fde68a}
.sym.U{background:#eff6ff;border-color:#bfdbfe}
.sym.B{background:#f5f5f5;border-color:#d4d4d4}
.sym.R{background:#fee2e2;border-color:#fecaca}
.sym.G{background:#ecfdf5;border-color:#bbf7d0}
.sym.C{background:#f3f4f6;border-color:#e5e7eb}
.rt{font-size:12px;color:#9ca3af;margin-left:6px}

/* トースト */
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:999px;display:none;z-index:50}

/* 右シート */
.sheet-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none}
.sheet{position:fixed;right:0;top:0;bottom:0;width:min(520px,100%);background:#fff;box-shadow:-10px 0 30px rgba(0,0,0,.2);display:none;flex-direction:column}
.sheet header{padding:16px;border-bottom:1px solid var(--border)}
.sheet .body{padding:16px;display:flex;flex-direction:column;gap:12px;overflow:auto;max-height:calc(100vh - 56px)}
.tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab{padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;cursor:pointer;font-size:13px}
.tab.active{background:#111;border-color:#111;color:#fff}
.note{font-size:12px;color:var(--muted);line-height:1.6}
.msg{font-size:14px}
.item{display:flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:10px;padding:8px}
.item a{color:#111;text-decoration:none}
.item a:hover{text-decoration:underline}

/* ミニグラフ */
.mini-wrap{flex:1; display:flex; align-items:center; gap:8px}
.mini-bar{ position:relative; height:18px; width:100%; background:#f3f4f6; border:1px solid #e5e7eb; border-radius:4px; overflow:hidden; }
.mini-seg{position:absolute; top:0; bottom:0}
.mini-seg.b1{background:var(--c1)} .mini-seg.b2{background:var(--c2)}
.mini-seg.b3{background:var(--c3)} .mini-seg.b4{background:var(--c4)}
.mini-overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; line-height:1; padding:0 6px; color:#111; background:rgba(255,255,255,.86); opacity:0; transition:opacity .15s; }
.mini-bar:hover .mini-overlay{opacity:1}

/* 選択チップ（登録/タグ編集UI） */
.chip-sel{border:1px solid var(--border);border-radius:999px;background:#fff;padding:6px 8px;font-size:12px;cursor:pointer;margin:2px}
.chip-sel.on{background:#111;color:#fff;border-color:#111}

/* Xボタン */
.xbtn{display:inline-flex;align-items:center;gap:6px;font-weight:700;background:#000;color:#fff;border:1px solid #000;border-radius:999px;padding:7px 12px;white-space:nowrap}
.xbtn svg{width:14px;height:14px;flex:0 0 auto}

/* 簡易モーダル */
.modal-back{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;z-index:60}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(560px,92vw);background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:none;flex-direction:column;z-index:61}
.modal header{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal .body{padding:12px 14px;max-height:60vh;overflow:auto}
.modal .foot{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid var(--border)}

/* ====== 見た目を小さく控えめに（上書き） ====== */
.tag-chips{ gap:4px; }
.tagchip{
  font-size:11px;
  padding:2px 6px;
  border-radius:6px;
  line-height:1.2;
  background:#fafafa;
  border-color:#e6e6e6;
  color:#475569;
}
.tagchip.theme{
  background:#f6f8ff;
  border-color:#dbe4ff;
}

/* 登録/編集モーダルの選択チップ */
.chip-sel{
  font-size:11px;
  padding:5px 8px;
  border-radius:12px;
}

/* === ヘッダー右ボタンをモバイルで小さく・同一行に収める === */
header { align-items: center; }
.title { flex: 1 1 auto; min-width: 0; }
#openSheet { flex: 0 0 auto; white-space: nowrap; }

/* ===== SPレイアウト（まとめて1ブロックでクローズ） ★ 修正：@media の閉じ漏れを整理 ===== */
@media (max-width: 680px){
  #openSheet{
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 8px;
    line-height: 1.1;
  }
  .site{ font-size: 18px; }
  .deck-meta{ font-size: 12px; gap: 8px; }

  /* headerを2カラムに（左：タイトル/タグ、右：ボタン） */
  header{
    position: relative;
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: start;
    gap: 8px;
  }
  #openSheet{
    justify-self: end;
    align-self: start;
  }
  .title{ min-width: 0; }
  .deck-meta{
    display: flex;
    align-items: center;
    gap: 6px;
    min-width: 0;
  }

  /* ボタンは右上に固定、タグは自動幅＋必要なら改行 */
  header{ display:block; }
  #openSheet{
    position: absolute;
    top: 6px;
    right: 8px;
    z-index: 1;
  }
  #deckTags.tag-chips{
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    width: 100%;
    overflow: visible;
  }
  #deckTags .tagchip{
    flex: 0 0 auto;
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* さらに控えめ（モバイル） */
  .tagchip{ font-size:10px; padding:2px 5px; border-radius:4px; }
  .chip-sel{ font-size:10px; padding:4px 6px; border-radius:4px; }
  .tag-chips{ gap:3px; }
}

/* テーマタグを控えめ強調 */
.tagchip.theme{
  background:#eef2ff;
  border-color:#cfd8ff;
  background: color-mix(in srgb, var(--accent) 16%, white);
  border-color: color-mix(in srgb, var(--accent) 42%, white);
  box-shadow: inset 0 0 0 1px rgba(99,102,241,.04);
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <a href="./" class="site" style="color:inherit;text-decoration:none">みんなでブラケット診断</a>
      <div class="deck-meta">
        <a class="deck-link" data-deck-title target="_blank" rel="noopener">#0000000</a>
        <span id="deckTags" class="tag-chips"></span>
      </div>
    </div>
    <button id="openSheet" class="small-btn">登録 / 確認</button>
  </header>

  <div class="grid">
    <div class="embed-wrap card">
      <iframe id="deckFrame" title="Hareruya Deck"
              sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation"
              loading="eager"></iframe>

      <div class="overlay" id="embedFail">
        <div class="box">
          <h3>ページを表示できませんでした</h3>
          <p>ブラウザや拡張機能の制限で埋め込みがブロックされる場合があります。下のリンクから新しいタブで開いてください。</p>
          <div class="row">
            <a id="openHareruyaLink" target="_blank" rel="noopener noreferrer">hareruyamtg.com で開く</a>
            <button id="retryEmbed">再読み込み</button>
          </div>
          <p class="note" style="margin-top:10px">※ iOS/Safariの場合、トラッキング防止/コンテンツブロッカー設定により表示されないことがあります。</p>
        </div>
      </div>
    </div>

    <div class="card vote-card">
      <div class="vote-block">
        <div class="prompt">このデッキのブラケットは？</div>
        <div class="vote-row">
          <button class="chip b1" data-vote="1" aria-pressed="false">１</button>
          <button class="chip b2" data-vote="2" aria-pressed="false">２</button>
          <button class="chip b3" data-vote="3" aria-pressed="false">３</button>
          <button class="chip b4" data-vote="4" aria-pressed="false">４</button>
        </div>
        <div class="skip-row">
          <button class="skip" id="skipBtn" title="このデッキは評価しない">回答しない</button>
        </div>
        <div class="hint">※ 同じデッキは1つだけ記録（変更可）</div>
      </div>

      <div class="results" id="results">
        <div class="bar" aria-label="集計バー">
          <div class="seg b1" id="seg1" style="left:0;width:0%"></div>
          <div class="seg b2" id="seg2" style="left:0;width:0%"></div>
          <div class="seg b3" id="seg3" style="left:0;width:0%"></div>
          <div class="seg b4" id="seg4" style="left:0;width:0%"></div>
        </div>
        <div class="legend">
          <span><i class="dot" style="background:var(--c1)"></i> 1 <b id="p1">0%</b></span>
          <span><i class="dot" style="background:var(--c2)"></i> 2 <b id="p2">0%</b></span>
          <span><i class="dot" style="background:var(--c3)"></i> 3 <b id="p3">0%</b></span>
          <span><i class="dot" style="background:var(--c4)"></i> 4 <b id="p4">0%</b></span>
        </div>

        <div class="action-row">
          <button id="nextBtn" class="small-btn primary">次のデッキへ</button>
          <span class="hint" id="autoNextHint" aria-live="polite"></span>
        </div>

        <!-- 理由チップ（10秒表示） -->
        <div id="reasonPanel" class="reason-wrap"></div>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="shareBtn" class="xbtn" title="シェア">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M18.244 2H21l-6.52 7.455L22 22h-6.843l-4.68-6.105L4.96 22H2.2l7.06-8.07L2 2h6.94l4.26 5.64L18.244 2Zm-1.197 18.4h1.83L7.03 3.52H5.09l11.958 16.88Z"/></svg>
          シェア
        </button>
        <button id="reportBtn" class="small-btn">削除希望</button>
      </div>

      <!-- Mana/XP -->
      <div class="mana-wrap" style="position:relative">
        <div id="manaSyms" class="mana-syms" aria-label="獲得マナ"></div>
        <div class="mana-bar"><i id="manaFill" style="width:0%"></i></div>
        <span class="rt" id="rtLabel" style="display:none">0sec</span>
      </div>
    </div>
  </div>

  <div class="card search-card" style="margin-top:16px">
    <div class="search-row">
      <input type="text" id="searchInput" placeholder="例: https://www.hareruyamtg.com/decks/0000000  または 0000000" aria-label="デッキ検索入力欄">
      <button id="searchBtn" class="small-btn">検索</button>
    </div>
  </div>

  <footer class="card" style="margin-top:16px">
    <div class="note">
      ※ 本サイトは外部サイトのページを埋め込み表示します。掲載URLはユーザー投稿であり、
      内容の正確性・合法性を保証しません。著作権等の権利は各権利者に帰属します。
      不適切・権利侵害の疑いがあるURLは「削除希望」からご連絡ください。必要に応じて削除対応します。
    </div>
  </footer>
</div>

<!-- 右シート -->
<div class="sheet-backdrop" id="backdrop"></div>
<aside class="sheet" id="sheet" aria-modal="true" role="dialog">
  <header>
    <div style="font-weight:700">登録 / 確認</div>
    <button id="closeSheet" class="small-btn right">閉じる</button>
  </header>
  <div class="body">
    <div class="tabs" role="tablist">
      <button class="tab active" data-tab="reg"  role="tab" aria-selected="true">登録</button>
      <button class="tab"         data-tab="mine" role="tab" aria-selected="false">自分のデッキ</button>
      <button class="tab"         data-tab="del"  role="tab" aria-selected="false">削除依頼</button>
    </div>

    <div id="pane-reg">
      <div class="note">
        晴れる屋デッキのURL（または数字ID）を入力して「登録」<br>
        <b>※公開範囲は「全員に公開」に設定してください。</b>
      </div>
      <div class="search-row">
        <input type="text" id="regUrl" placeholder="例: https://www.hareruyamtg.com/decks/0000000">
        <button id="regBtn" class="small-btn">登録</button>
      </div>

      <!-- ▼ 追加：登録時のタグ入力（任意 / 自由タグは最大3件） -->
      <div style="margin-top:10px">
        <div class="note" style="margin-bottom:6px">任意でタグを付けられます（変更可）</div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <label for="regTheme" class="note">デッキの狙い:</label>
          <select id="regTheme"></select>
        </div>
        <div class="note" style="margin:6px 0 4px">タグ（最大3つ / 複数可）:</div>
        <div id="regTagBox" style="display:flex;flex-wrap:wrap"></div>
        <div id="regTagHint" class="note"></div>
      </div>

      <div class="msg" id="regMsg"></div>
    </div>

    <div id="pane-del" style="display:none">
      <div class="note">削除してほしいデッキのURL（または数字ID）を入力して「通報」。一定数で自動削除。</div>
      <div class="search-row">
        <input type="text" id="delUrl" placeholder="例: https://www.hareruyamtg.com/decks/0000000">
        <button id="delBtn" class="small-btn">通報</button>
      </div>
      <div class="msg" id="delMsg"></div>
    </div>

    <div id="pane-mine" style="display:none">
      <div class="note">あなたが登録したデッキ一覧（最大50件）。ここから削除できます。</div>
      <div style="display:flex;gap:8px;margin-bottom:6px">
        <button id="reloadMine" class="small-btn">更新</button>
      </div>
      <div id="mineList" style="display:flex;flex-direction:column;gap:8px"></div>
    </div>
  </div>
</aside>

<!-- 簡易モーダル（理由一覧 / タグ編集で使用） -->
<div id="modalBack" class="modal-back"></div>
<div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <header>
    <div id="modalTitle" style="font-weight:700">Title</div>
    <button id="modalClose" class="small-btn">閉じる</button>
  </header>
  <div id="modalBody" class="body"></div>
  <div class="foot">
    <button id="modalSave" class="small-btn primary" style="display:none">保存</button>
  </div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* ===== Supabase 設定 ===== */
const SUPABASE_URL  = "https://onzljxnqlrohkzsfxqbh.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9uemxqeG5xbHJvaGt6c2Z4cWJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1NzUzNTksImV4cCI6MjA3MTE1MTM1OX0.eLAP_-PtVm6tBFFCNfOVsTqEcvtZK3x3QFFNeRpxuj8";
const FN_INGEST     = `${SUPABASE_URL}/functions/v1/ingest-hareruya`;
const FN_REPORT     = `${SUPABASE_URL}/functions/v1/report-deck`;
const FN_VOTE       = `${SUPABASE_URL}/functions/v1/vote`;
const FN_SKIP       = `${SUPABASE_URL}/functions/v1/skip`;
const FN_VALIDATE  = `${SUPABASE_URL}/functions/v1/hareruya-validate`;


/* 共有URLは末尾 index.html を外す ★ 修正 */
const APP_URL = (() => {
  const pathNoIndex = location.pathname.replace(/index\.html?$/i, "");
  return `${location.origin}${pathNoIndex || "/"}`;
})();

/* ===== Supabase クライアント ===== */
const sb = createClient(SUPABASE_URL, SUPABASE_ANON, {
  auth: { persistSession:false, autoRefreshToken:false },
  global: { headers: { apikey: SUPABASE_ANON } }
});

/* ====== スキーマ検出 ====== */
const __SCHEMA = { kind: null };
async function detectSchema(){
  if (__SCHEMA.kind) return __SCHEMA.kind;
  try{
    const q = await sb.from("deck_tags").select("tag_key").limit(1);
    if (!q.error) { __SCHEMA.kind = "new"; return "new"; }
  }catch{}
  __SCHEMA.kind = "old"; return "old";
}

/* ===== Util ===== */
function extractDeckIdFromUrl(u){
  return (String(u||"").match(/decks\/(\d{4,})/) || String(u||"").match(/^(\d{4,})$/) || [])[1] || null;
}
async function findDeckByUrlOrId(url){
  // 1) URL 完全一致
  let r = await sb.from("decks")
    .select("id,source_url,deck_name,deck_text_ja,registered_at")
    .eq("source_url", url).maybeSingle();
  if (r?.data?.id) return r.data;

  // 2) ID 一致（URL 正規化違いの救済）
  const id = extractDeckIdFromUrl(url);
  if (id){
    r = await sb.from("decks")
      .select("id,source_url,deck_name,deck_text_ja,registered_at")
      .eq("id", id).maybeSingle();
    if (r?.data?.id) return r.data;
  }
  return null;
}
const $ = (q)=>document.querySelector(q);
const toastEl = $("#toast");
function toast(msg){ try{ toastEl.textContent=msg; toastEl.style.display="block"; clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.style.display="none", 1600);}catch{} }
const sid = (localStorage.getItem("sid") || (crypto?.randomUUID?.() ? crypto.randomUUID() : String(Math.random()).slice(2)+"-"+Date.now()));
localStorage.setItem("sid", sid);
function toDeckId(input){
  const s = String(input||"").trim();
  return s.match(/decks\/(\d+)/)?.[1]
      || s.match(/deck\.hareruyamtg\.com\/(\d+)/)?.[1]
      || (/^\d{4,}$/.test(s) ? s : null);
}
function canonUrl(input){ const id = toDeckId(input); return id ? `https://www.hareruyamtg.com/decks/${id}` : null; }

/* ===== 晴れる屋の公開/存在チェック＋日本語デッキテキスト保存（Edge側で判定＆保存） ===== */
async function validateHareruya(url){
  const res = await fetch(FN_VALIDATE, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": "Bearer " + SUPABASE_ANON,
      "apikey": SUPABASE_ANON
    },
    body: JSON.stringify({ url })
  });
  const j = await res.json().catch(()=> ({}));
  if (!res.ok) throw new Error(j?.error || `validator_${res.status}`);

  // 非公開/削除はここで弾く
  if (j?.ok && j.public === false) {
    const r = String(j?.reason || "");
    if (r === "private")      throw new Error("deck_private");
    if (r === "not_found")    throw new Error("deck_not_found");
    throw new Error("deck_unavailable");
  }
  // j: { ok:true, public:true, saved:boolean, has_text:boolean, deck_text_ja?, title? }
  return j;
}

/* ===== log_impression: 互換ヘルパー ===== */
async function safeLogImpression(deckId){
  try{
    const r = await sb.rpc("log_impression", { p_session: sid, p_deck: deckId });
    if(!r.error) return;
  }catch{}
  try{ await sb.rpc("log_impression", { session_id: sid, deck_id: deckId }); }catch{}
}

/* ===== マスター（テーマ/タグ/理由） ===== */
/* フォールバック（ラベルのみ） */
let MASTER = {
  themes: ["コンボ","コンセプト","殴り","コントロール","スタックス","墓地利用","トークン","テンポ","ミッドレンジ","ランプ","その他"],
  tags:   ["部族","ブリンク","カウンター","トークン","墓地利用","ライフゲイン","宝物","ランプ","ロック","妨害","ヘイトベアー","増殖","コピー","装備品","打消し多め","速攻","全体除去","エンチャント多め","アーティファクト多め","多色","単色","二色","三色","５色","部族：エルフ","部族：ゴブリン","部族：人間","部族：スピリット","フレーバー重視"]
};
/* 理由マスタ（label-reason 用：key/label） */
let REASONS_MASTER = []; // { key, label }[]

async function ensureMasters(){
  try {
    const t = await sb.from("app_tags_master").select("kind,key,label").limit(2000);
    if (!t.error && t.data?.length){
      const themes = t.data.filter(x=>x.kind==="theme").map(x=>x.label || x.key);
      const tags   = t.data.filter(x=>x.kind==="tag").map(x=>x.label || x.key);
      if (themes.length) MASTER.themes = themes;
      if (tags.length)   MASTER.tags   = tags;
    }
  } catch {}
  try {
    const r = await sb.from("app_reasons_master").select("key,label").limit(2000);
    if (!r.error && r.data?.length){
      REASONS_MASTER = r.data.map(x => ({ key: String(x.key), label: String(x.label || x.key) }));
    }
  } catch {}
}
await ensureMasters();

/* ===== 簡易モーダル ===== */
const modalBack = $("#modalBack"), modal = $("#modal"), modalTitle=$("#modalTitle"), modalBody=$("#modalBody"), modalSave=$("#modalSave");
$("#modalClose").addEventListener("click", closeModal);
modalBack.addEventListener("click", closeModal);
function openModal(title, content, saveVisible=false, onSave=null){
  modalTitle.textContent = title;
  modalBody.innerHTML = "";
  if (content instanceof HTMLElement) modalBody.replaceChildren(content);
  else modalBody.innerHTML = String(content ?? "");
  modalSave.style.display = saveVisible ? "inline-flex" : "none";
  modal.style.display = "flex"; modalBack.style.display="block";
  modalSave.onclick = saveVisible && typeof onSave==="function" ? onSave : null;
}
function closeModal(){ modal.style.display="none"; modalBack.style.display="none"; modalSave.onclick=null; }

/* ===== 埋め込み ===== */
const frame = $("#deckFrame"), fail = $("#embedFail");
const openHareruyaLink = $("#openHareruyaLink"), retryEmbed = $("#retryEmbed");
let embedWatch = null;
function setEmbed(inputUrl){
  const s = String(inputUrl || "").trim();
  const m = s.match(/decks\/(\d+)/) || s.match(/deck\.hareruyamtg\.com\/(\d+)/) || s.match(/^(\d{4,})$/);
  const id = m ? m[1] : null;
  if (!id) { frame.src = "about:blank"; fail.style.display="flex"; return; }
  const wwwUrl  = `https://www.hareruyamtg.com/decks/${id}`;
  openHareruyaLink.href = wwwUrl;
  fail.style.display="none"; frame.removeAttribute("src"); frame.src = wwwUrl;
  clearTimeout(embedWatch); embedWatch = setTimeout(()=>{ fail.style.display="flex"; }, 6000);
}
frame.addEventListener("load", ()=>{ clearTimeout(embedWatch); try{ fail.style.display="none"; }catch{} });
retryEmbed?.addEventListener("click", ()=> { if (currentDeck?.source_url) setEmbed(currentDeck.source_url); });

/* ===== 状態 ===== */
let currentDeck = null;
let autoNextTimer = null;
let deckShownAtMs = 0;
let hadMyVoteBefore = false;
let reasonXpGiven = false;

/* ===== 集計 ===== */
const resultsEl = $("#results");
const seg1=$("#seg1"), seg2=$("#seg2"), seg3=$("#seg3"), seg4=$("#seg4");
const p1=$("#p1"), p2=$("#p2"), p3=$("#p3"), p4=$("#p4");
const nextBtn=$("#nextBtn"); const autoNextHint=$("#autoNextHint");
const reasonPanel = $("#reasonPanel");

function renderChart(c1,c2,c3,c4){
  const total=Math.max(0,c1+c2+c3+c4);
  const per = total? [c1/total*100,c2/total*100,c3/total*100,c4/total*100]:[0,0,0,0];
  const l1 = 0, l2 = per[0], l3 = per[0]+per[1], l4 = per[0]+per[1]+per[2];
  seg1.style.left=l1+"%"; seg1.style.width=per[0]+"%";
  seg2.style.left=l2+"%"; seg2.style.width=per[1]+"%";
  seg3.style.left=l3+"%"; seg3.style.width=per[2]+"%";
  seg4.style.left=l4+"%"; seg4.style.width=per[3]+"%";
  p1.textContent=Math.round(per[0])+"%";
  p2.textContent=Math.round(per[1])+"%";
  p3.textContent=Math.round(per[2])+"%";
  p4.textContent=Math.round(per[3])+"%";
}

/* 5秒未満は除外。ただし「rt_sec が null/未保存」の古い投票は含める */
function passRtFilter(rt){ return (rt==null) || (Number(rt) >= 5); }

async function loadVotesAndRenderResults(forceShow=false){
  if(!currentDeck) return;
  let c1=0,c2=0,c3=0,c4=0;

  // 1) RPC（ある場合）
  try{
    const rpc = await sb.rpc('labels_counts_by_deck', { p_deck: currentDeck.id, p_min_rt: 5, p_include_null:true });
    if(!rpc.error && Array.isArray(rpc.data) && rpc.data.length){
      for(const r of rpc.data){
        if(r.bracket===1) c1=r.cnt|0;
        else if(r.bracket===2) c2=r.cnt|0;
        else if(r.bracket===3) c3=r.cnt|0;
        else if(r.bracket===4) c4=r.cnt|0;
      }
      renderChart(c1,c2,c3,c4);
      if(forceShow) resultsEl.style.display="flex";
      return;
    }
  }catch{}

  // 2) REST→JS集計
  try{
    const { data } = await sb.from("labels").select("bracket,rt_sec").eq("deck_id", currentDeck.id).limit(10000);
    for(const r of (data||[])){
      if (!passRtFilter(r.rt_sec)) continue;
      if(r.bracket===1)c1++; else if(r.bracket===2)c2++; else if(r.bracket===3)c3++; else if(r.bracket===4)c4++;
    }
  }catch{}
  renderChart(c1,c2,c3,c4);
  if(forceShow) resultsEl.style.display="flex";
}

/* ===== 自分の投票 ====== */
const voteChips = Array.from(document.querySelectorAll(".chip[data-vote]"));
function markMyVote(bracket){
  for(const btn of voteChips){
    const isSel = Number(btn.dataset.vote) === Number(bracket);
    btn.classList.toggle("selected", !!bracket && isSel);
    btn.setAttribute("aria-pressed", String(!!bracket && isSel));
  }
}
async function loadMyVote(){
  if(!currentDeck) { markMyVote(null); hadMyVoteBefore=false; return null; }
  const { data } = await sb.from("labels").select("bracket").eq("deck_id", currentDeck.id).eq("session_id", sid).maybeSingle();
  const b = data?.bracket ?? null;
  hadMyVoteBefore = b !== null;
  markMyVote(b);
  return b;
}

/* ===== Mana/XP ===== */
const xpKey = "xp_v3";
const manaFill=$("#manaFill"), manaSyms=$("#manaSyms"), rtLabel=$("#rtLabel");
const lvNeed = [10,30,70,150,310,630,1270,2550,5110,10230,20470,40950,81910,163830,327670,655350];
function loadXP(){ try{ return JSON.parse(localStorage.getItem(xpKey)||"{}"); }catch{ return {}; } }
function saveXP(s){ localStorage.setItem(xpKey, JSON.stringify(s)); }
function ensureXP(){
  const s = loadXP();
  if(s.xp==null) s.xp=0; if(s.lv==null) s.lv=0;
  if(!s.mana) s.mana={ C:0, W:0, U:0, B:0, R:0, G:0 };
  if(!s.hist) s.hist=[]; if(s.cp==null) s.cp=0;
  return s;
}
function circled(n){ return String(n); } // ①②などは使わず通常の数字に
function isDbl(sec){ return sec===11||sec===22||sec===33||sec===44||sec===55; }
function updateXpUI(){
  const s = ensureXP();
  const need = (s.lv ? (lvNeed[s.lv]-lvNeed[s.lv-1]) : lvNeed[0]);
  const prev = (s.lv ? lvNeed[s.lv-1] : 0);
  const cur  = Math.max(0, s.xp - prev);
  const pct  = Math.max(0, Math.min(100, need ? Math.round(cur / need * 100) : 0));
  manaFill.style.width = pct + "%";

  const order = ["C","W","U","B","R","G"];
  const syms = [];
  // 無色は数字（1,2,3...）
  if ((s.mana.C||0) > 0) syms.push(`<span class="sym C">${s.mana.C}</span>`);
  // 有色は色だけ（文字なし）
  for (let oi=1; oi<order.length; oi++) {
    const k = order[oi];
    const cnt = s.mana[k] || 0;
    for (let i=0; i<cnt; i++) syms.push(`<span class="sym ${k}" title="${k}"></span>`);
  }
  manaSyms.innerHTML = syms.join("");
}
function pushHistory(rtSec){
  const d = new Date();
  const rec = { t:d.toISOString(), h:d.getHours(), sec:d.getSeconds(), rt:rtSec };
  const s = ensureXP(); s.hist.push(rec); saveXP(s);
}
function showManaPop(color){
  const e = document.createElement("div");
  e.className="mana-pop";
  e.innerHTML = `<span class="sym ${color}">${color==="C" ? "1" : ""}</span>`;
  document.body.appendChild(e);
  setTimeout(()=>{ try{ e.remove(); }catch{} }, 900);
}
function awardManaOnLevelUp(){
  const s = ensureXP();
  const slice = s.hist.slice(s.cp);
  const last  = s.hist[s.hist.length-1] || null;

  if (last){
    if (isDbl(last.sec)){ s.mana.U = (s.mana.U||0)+1; s.cp=s.hist.length; saveXP(s); showManaPop("U"); updateXpUI(); return; }
    if ((last.sec%10)===0){ s.mana.C = (s.mana.C||0)+1; s.cp=s.hist.length; saveXP(s); showManaPop("C"); updateXpUI(); return; }
  }
  let am=0, pm=0, sum=0;
  for(const r of slice){ if(r.h<12) am++; else pm++; sum+=(r.rt||0); }
  const avg = slice.length ? (sum/slice.length) : 0;
  const isPM = pm>=am;
  let color = "C";
  if (isPM && avg<=20) color="R";
  else if (!isPM && avg>=50) color="G";
  else if (!isPM && avg>=21 && avg<=49) color="W";
  else if (isPM && avg>=21 && avg<=49) color="B";
  s.mana[color] = (s.mana[color]||0)+1; s.cp=s.hist.length; saveXP(s);
  showManaPop(color); updateXpUI();
}
function addXPIfFirstVote(rtSec, isFirst){
  const s = ensureXP();
  if (isFirst){
    s.xp = (s.xp || 0) + 1;
    const secNow = new Date().getSeconds();
    if (isDbl(secNow)) s.xp = s.xp + 1;
    saveXP(s);
  }
  const nextLvNeed = lvNeed[Math.min(s.lv, lvNeed.length-1)] ?? Infinity;
  if (s.xp >= nextLvNeed){ s.lv = s.lv + 1; s.cp = s.hist.length; saveXP(s); awardManaOnLevelUp(); }
  updateXpUI();
}
function addExtraXPOnce(){
  if (reasonXpGiven) return;
  const s = ensureXP(); s.xp = (s.xp||0) + 1; saveXP(s); reasonXpGiven = true; updateXpUI();
}

/* ===== 理由チップ（label-reasonに統一） ===== */
function showReasonPanel(){
  reasonXpGiven = false;
  reasonPanel.innerHTML = "";
  const source = REASONS_MASTER.length ? REASONS_MASTER : (MASTER.reasons||[]).map((lab, i)=>({ key: lab, label: lab }));
  for(const {key,label} of source){
    const b = document.createElement("button");
    b.className = "reason-btn";
    b.type="button"; b.textContent = label;
    b.dataset.key = key;
    b.addEventListener("click", ()=> recordReasonKey(key, b));
    reasonPanel.appendChild(b);
  }
  reasonPanel.style.display = "flex";
  setTimeout(()=>{ reasonPanel.style.display="none"; }, 10000);
}
async function recordReasonKey(reason_key, btn){
  if (!currentDeck) return;
  let ok=false;
  // 1) Edge: label-reason
  try{
    const res = await fetch(`${SUPABASE_URL}/functions/v1/label-reason`, {
      method:"POST",
      headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON },
      body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, reasons: [reason_key] })
    });
    const j = await res.json().catch(()=> ({}));
    ok = res.ok && j?.ok!==false;
  }catch{}
  // 2) 直書きフォールバック
  if(!ok){
    try{
      const ins = await sb.from("label_reasons").upsert([{ deck_id: currentDeck.id, session_id: sid, reason_key }]);
      ok = !ins.error;
    }catch{}
  }
  if(ok){ btn.classList.add("on"); addExtraXPOnce(); }
}

/* タイトル右のタグ表示（新→旧） */
function tagChip(txt, kind){
  const el = document.createElement("span");
  el.className = "tagchip " + (kind || "free");
  el.textContent = txt;
  return el;
}
async function showDeckTags(deck_id){
  const box = $("#deckTags");
  box.innerHTML = "";
  if (!deck_id) return;

  // 1) 新スキーマ（decks.theme_key / deck_tags.tag_key）
  try{
    const [deckRow, tagRows] = await Promise.all([
      sb.from("decks").select("theme_key").eq("id", deck_id).maybeSingle(),
      sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id).limit(200)
    ]);

    const themeKey = deckRow?.data?.theme_key || null;
    const tagKeys  = (tagRows?.data||[]).map(r=>r?.tag_key).filter(Boolean);
    const allKeys  = [...new Set([themeKey, ...tagKeys].filter(Boolean))];

    if (allKeys.length){
      const { data: masters } = await sb
        .from("app_tags_master").select("key,label,kind").in("key", allKeys).limit(500);

      const byKey   = new Map((masters||[]).map(m => [m.key, m]));
      const labelOf = (k) => byKey.get(k)?.label || k;
      const kindOf  = (k) => byKey.get(k)?.kind  || "tag";

      let themeLabel = null, themeResolvedKey = null;

      if (themeKey){ themeLabel = labelOf(themeKey); themeResolvedKey = themeKey; }
      if (!themeLabel){
        const tk = tagKeys.find(k => kindOf(k)==="theme");
        if (tk){ themeLabel = labelOf(tk); themeResolvedKey = tk; }
      }
      if (!themeLabel){
        const tCand = tagKeys.find(k => (MASTER?.themes||[]).includes(labelOf(k)));
        if (tCand){ themeLabel = labelOf(tCand); themeResolvedKey = tCand; }
      }

      if (themeLabel) box.appendChild(tagChip(themeLabel, "theme"));

      const tagLabels = tagKeys
        .filter(k => k !== themeResolvedKey)
        .filter(k => kindOf(k)==="tag")
        .map(labelOf);

      for (const lab of [...new Set(tagLabels)].slice(0,3)){
        box.appendChild(tagChip(lab, "free"));
      }
      if (box.children.length) return;
    }
  }catch{}

  // 2) 旧スキーマ（deck_tags.theme / deck_tags.tags）
  try{
    const q = await sb.from("deck_tags").select("theme,tags").eq("deck_id", deck_id).maybeSingle();
    if (!q.error && (q.data?.theme || Array.isArray(q.data?.tags))){
      if (q.data.theme) box.appendChild(tagChip(q.data.theme, "theme"));
      for (const t of (Array.isArray(q.data.tags)? q.data.tags : []).slice(0,3)){
        box.appendChild(tagChip(t, "free"));
      }
    }
  }catch{}
}

/* ===== 表示 ===== */
async function showDeckByRow(row,{showResults=false}={}){
  currentDeck = row;
  reasonXpGiven = false;
  setEmbed(row.source_url);

  const id = toDeckId(row.source_url);
  if (id) history.replaceState(null, "", `${APP_URL}?deck=${id}`);

  const titleEl=document.querySelector('[data-deck-title]');
  titleEl.textContent = id ? `#${id}` : "#???????";
  titleEl.href = row.source_url;

  await showDeckTags(row.id);

  $("#results").style.display = showResults ? "flex":"none";
  await loadVotesAndRenderResults(showResults);
  await loadMyVote();

  clearInterval(autoNextTimer); autoNextTimer=null; autoNextHint.textContent="";
  nextBtn.classList.remove("pulse");

  try{ await safeLogImpression(row.id); }catch{}

  deckShownAtMs = performance.now();
}

/* ===== ランダム ===== */
async function loadRandomDeck(){
  const { data, error } = await sb.rpc("random_deck_for_session", { p_session: sid });
  if (error) { toast("読み込みエラー"); return; }
  const row = (Array.isArray(data) ? data[0] : null);
  if (!row) { toast("未回答のデッキがありません"); return; }

  // 表示直前ゲート：非公開/404は自動スキップ（セッション記録）
  try{
    const v = await validateHareruya(row.source_url);
    if (v?.deck_text_ja && !row.deck_text_ja){
      try{ await sb.from("decks").update({ deck_text_ja: v.deck_text_ja }).eq("id", row.id); row.deck_text_ja = v.deck_text_ja; }catch{}
    }
  }catch(e){
    const code = String(e?.message || e);
    if (code.startsWith("deck_")) {
      try{
        await fetch(FN_SKIP, {
          method:"POST",
          headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON },
          body: JSON.stringify({ deck_id: row.id, session_id: sid, reason: "auto_invalid" })
        });
      }catch{}
      // 次を読む
      await loadRandomDeck();
      return;
    }
  }

  await showDeckByRow(row,{showResults:false});
}

/* ===== 存在確認（未登録なら：検証→OK→登録→テキスト補完） ===== */
async function ensureDeckExists(url){
  // 1) 表示前ゲート：必ず検証（非公開/404ならここで終了）
  //    Edge 側で deck_text_ja も生成・保存する
  const v = await validateHareruya(url); // 失敗時は例外 deck_private / deck_not_found / deck_unavailable

  // 2) 既存チェック
  let sel = await sb.from("decks")
    .select("id,source_url,deck_name,deck_text_ja,registered_at")
    .eq("source_url", url).maybeSingle();

  if (sel?.data?.id){
    // deck_text_ja が空なら、validator 由来を補完
    if (!sel.data.deck_text_ja && v?.deck_text_ja){
      try{
        await sb.from("decks").update({ deck_text_ja: v.deck_text_ja }).eq("id", sel.data.id);
        sel.data.deck_text_ja = v.deck_text_ja;
      }catch{}
    }
    return sel.data;
  }

  // 3) 未登録 → Edge へ登録要求
  const res = await fetch(FN_INGEST,{
    method:"POST",
    headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON },
    body: JSON.stringify({ url, session_id:sid })
  });
  const j = await res.json().catch(()=> ({}));

  // 409（already_registered）を吸収：サーバが data を返せばそれを採用
  if (res.status === 409 || j?.error === "already_registered") {
    if (j?.data?.id) return j.data;
    const again = await sb.from("decks")
      .select("id,source_url,deck_name,deck_text_ja,registered_at")
      .eq("source_url", url).maybeSingle();
    if (again?.data) return again.data;
    throw new Error("already_registered_but_not_readable");
  }

  // 新規作成成功：Edge の戻り値を第一ソースに
  if (res.ok && j?.ok && j?.data?.id) {
    const row = j.data;
    if (!row.deck_text_ja && v?.deck_text_ja){
      try{
        await sb.from("decks").update({ deck_text_ja: v.deck_text_ja }).eq("id", row.id);
        row.deck_text_ja = v.deck_text_ja;
      }catch{}
    }
    return row;
  }

  // 最終フォールバック
  sel = await sb.from("decks")
    .select("id,source_url,deck_name,deck_text_ja,registered_at")
    .eq("source_url", url).maybeSingle();
  if (sel?.data?.id) return sel.data;

  throw new Error(j?.error || "登録に失敗しました");
}
/* ===== 検索欄（URL / 数字ID） ===== */
const searchInput = document.getElementById("searchInput");
const searchBtn   = document.getElementById("searchBtn");

// 二重バインド防止
function bindOnce(el, type, handler, opts){
  if (!el) return;
  const key = `__bound_${type}`;
  if (el[key]) return;
  el.addEventListener(type, handler, opts);
  el[key] = true;
}

async function runSearch(){
  const v = (searchInput?.value || "").trim();
  const url = canonUrl(v);
  if (!url) { toast("URL または 数字ID を入力してください"); searchInput?.focus(); return; }
  try {
    const row = await ensureDeckExists(url);         // 未登録なら登録→取得
    await showDeckByRow(row, { showResults: true }); // 右側に結果表示
  } catch (e) {
    toast("デッキの取得に失敗しました: " + String(e?.message ?? e));
  }
}

// IME中のEnterは無視
let composing = false;
bindOnce(searchInput, "compositionstart", ()=> composing = true);
bindOnce(searchInput, "compositionend",  ()=> composing = false);

// クリック/Enter を1か所に集約
bindOnce(searchBtn,   "click",  (e)=> { e.preventDefault(); runSearch(); });
bindOnce(searchInput, "keydown", (e)=> {
  if (!composing && e.key === "Enter") { e.preventDefault(); runSearch(); }
});

/* ===== 投票 ===== */
let voting = false;
function setVoting(b){ voting=b; for(const btn of voteChips){ btn.disabled=b; } }

async function postVoteOnce(bracket, rtSec){
  const res = await fetch(FN_VOTE, {
    method: "POST",
    headers: { "Content-Type": "application/json","Authorization": "Bearer " + SUPABASE_ANON,"apikey": SUPABASE_ANON },
    body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, bracket, rt_sec: rtSec })
  });
  let ok = res.ok;
  try{ const j = await res.clone().json(); if (j && j.ok === false) ok = false; }catch{}
  return { ok, status: res.status };
}
async function postVoteWithRetry(bracket, rtSec){
  const retriable = new Set([429,409,500,502,503,504]);
  for (let i=0; i<2; i++){
    const { ok, status } = await postVoteOnce(bracket, rtSec);
    if (ok) return true;
    if (!retriable.has(status)) return false;
    await new Promise(r=>setTimeout(r, 250));
  }
  return false;
}
for (const el of document.querySelectorAll(".chip[data-vote]")){
  el.addEventListener("click", async (e)=>{
    if (!currentDeck || voting) return;
    const bracket = Number(e.currentTarget.dataset.vote);
    setVoting(true);
    try{
      const rtSec = Math.max(0, Math.round((performance.now() - deckShownAtMs)/1000));
      const done = await postVoteWithRetry(bracket, rtSec);
      if (!done){ toast("保存エラー。時間を空けて再試行してください。"); return; }

      const wasFirst = !hadMyVoteBefore;

      markMyVote(bracket);
      resultsEl.style.display="flex";
      nextBtn.classList.add("pulse");
      await loadVotesAndRenderResults(true);

      rtLabel.style.display="inline"; rtLabel.textContent = `${rtSec}sec`;
      pushHistory(rtSec);
      addXPIfFirstVote(rtSec, wasFirst);
      hadMyVoteBefore = true;

      // 理由チップ（10秒）
      reasonPanel.style.display="flex";
      showReasonPanel();

      // 次へカウントダウン
      let left = 10;
      autoNextHint.textContent = `${left}秒後に自動で次のデッキへ`;
      clearInterval(autoNextTimer);
      autoNextTimer = setInterval(()=>{
        left--;
        if(left<=0){ clearInterval(autoNextTimer); autoNextTimer=null; reasonPanel.style.display="none"; loadRandomDeck(); }
        else autoNextHint.textContent = `${left}秒後に自動で次のデッキへ`;
      }, 1000);
    }catch{ toast("保存エラーが発生しました。"); }
    finally{ setVoting(false); }
  });
}

/* ===== スキップ・次へ ===== */
async function onSkip(){
  try{
    if (currentDeck) {
      await fetch(FN_SKIP, { method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid }) });
    }
  }catch{}
  clearInterval(autoNextTimer); autoNextTimer=null;
  reasonPanel.style.display="none";
  await loadRandomDeck();
}
$("#skipBtn").addEventListener("click", onSkip);
nextBtn.addEventListener("click", ()=> { clearInterval(autoNextTimer); autoNextTimer=null; reasonPanel.style.display="none"; loadRandomDeck(); });

/* ===== 共有 ===== */
function currentDeckLink(){
  const id = currentDeck ? toDeckId(currentDeck.source_url) : null;
  return id ? `${APP_URL}?deck=${id}` : APP_URL;
}
function shareCurrentDeck(){
  const url = currentDeckLink();
  const tw = new URL("https://x.com/intent/tweet");
  tw.searchParams.set("text", "このデッキのブラケットは？ #みんなでブラケット診断");
  tw.searchParams.set("url", url);
  const w = window.open(tw.toString(), "_blank", "noopener,noreferrer");
  if (!w) { location.href = tw.toString(); }
}
$("#shareBtn").addEventListener("click", shareCurrentDeck);

/* ===== 通報 ===== */
$("#reportBtn").addEventListener("click", async ()=>{
  if(!currentDeck) return toast("デッキ未読込です");
  const btn = $("#reportBtn"); const orig = btn.textContent;
  btn.textContent="送信中…"; btn.classList.add("primary");
  try{
    const res = await fetch(FN_REPORT,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, reason:"user_report_from_vote" }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j?.ok!==false){ btn.textContent="完了！"; setTimeout(()=>{ btn.textContent=orig; btn.classList.remove("primary"); onSkip(); }, 900); }
    else{ btn.textContent=orig; btn.classList.remove("primary"); toast("報告に失敗しました"); }
  }catch{ btn.textContent=orig; btn.classList.remove("primary"); toast("報告に失敗しました"); }
});

/* ===== シート ===== */
const sheet=$("#sheet"), backdrop=$("#backdrop");
function openSheet(){ sheet.style.display="flex"; backdrop.style.display="block"; }
function closeSheet(){ sheet.style.display="none"; backdrop.style.display="none"; }
$("#openSheet").addEventListener("click", openSheet);
$("#closeSheet").addEventListener("click", closeSheet);
backdrop.addEventListener("click", closeSheet);

/* ===== タブ ===== */
const tabs = document.querySelectorAll(".tab");
for(const t of tabs){
  t.addEventListener("click", ()=>{
    for(const x of tabs){ x.classList.remove("active"); x.setAttribute('aria-selected','false'); }
    t.classList.add("active"); t.setAttribute('aria-selected','true');
    const name=t.dataset.tab;
    $("#pane-reg").style.display = name==="reg" ? "block":"none";
    $("#pane-del").style.display = name==="del" ? "block":"none";
    $("#pane-mine").style.display= name==="mine"? "block":"none";
    if(name==="mine") loadMine();
  });
}

/* ===== 登録：タグUI 初期化（自由タグは最大3つ） ===== */
const regThemeSel = $("#regTheme");
const regTagBox = $("#regTagBox");
const regTagHint = $("#regTagHint");
const regChosen = new Set();
function chip(htmlText, on, onclick){
  const s = document.createElement("button");
  s.type="button";
  s.className = "chip-sel"+(on?" on":"");
  s.innerHTML = htmlText;
  s.addEventListener("click", ()=>{
    onclick?.(!s.classList.contains("on"));
    const canToggle = s.dataset._allow==="1";
    if(!canToggle) return;
    s.classList.toggle("on");
  });
  return s;
}
function updateTagLimitUI(){
  const selCnt = regChosen.size;
  regTagHint.textContent = `選択数: ${selCnt}/3`;
  const lock = selCnt >= 3;
  for(const b of Array.from(regTagBox.querySelectorAll(".chip-sel"))){
    if(!b.classList.contains("on")){
      b.disabled = lock; b.style.opacity = lock ? ".6" : "1";
    }else{
      b.disabled = false; b.style.opacity = "1";
    }
  }
}
function initRegTagsUI(){
  // テーマ
  regThemeSel.innerHTML = `<option value="">未選択</option>` + MASTER.themes.map(v=> `<option value="${v}">${v}</option>`).join("");
  // タグ
  regTagBox.innerHTML = ""; regChosen.clear();
  for(const t of MASTER.tags){
    const c = chip(t, false, (willOn)=> {
      if(willOn && regChosen.size>=3){ c.dataset._allow="0"; return; }
      c.dataset._allow="1";
      if(willOn) regChosen.add(t); else regChosen.delete(t);
      updateTagLimitUI();
    });
    regTagBox.appendChild(c);
  }
  updateTagLimitUI();
}
initRegTagsUI();

/* タグ保存（新/旧スキーマ直書き。Edge set-tagsは使わない） */
async function saveTagsForDeck(deck_id, themeLabel, tagLabels){
  if (!deck_id) return false;
  const tagsArr = Array.from(new Set(Array.isArray(tagLabels) ? tagLabels : [])).slice(0,3);
  const kind = await detectSchema();

  if (kind === "new"){
    try{
      const { data: masters } = await sb.from("app_tags_master").select("key,label,kind").limit(2000);
      const toKey = (label, needKind)=> {
        const hit = (masters||[]).find(m => m.kind===needKind && (m.label===label || m.key===label));
        return hit?.key || label;
      };

      const tkey = themeLabel ? toKey(themeLabel, "theme") : null;
      const keys = tagsArr.map(l => toKey(l, "tag"));
      const rows = [
        ...(tkey ? [{ deck_id, tag_key: tkey, created_by_session: sid }] : []),
        ...keys.map(k => ({ deck_id, tag_key: k, created_by_session: sid }))
      ];

      const before = await sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id);
      await sb.from("deck_tags").delete().eq("deck_id", deck_id);
      if (rows.length){
        const ins = await sb.from("deck_tags").insert(rows);
        if (ins.error){
          if (Array.isArray(before.data) && before.data.length){
            const rb = before.data.map(r=>({ deck_id, tag_key: r.tag_key, created_by_session: sid }));
            await sb.from("deck_tags").insert(rb);
          }
          throw ins.error;
        }
      }
      if (tkey) await sb.from("decks").update({ theme_key: tkey }).eq("id", deck_id);
      return true;
    }catch{}
  }else{
    try{
      await sb.from("deck_tags").delete().eq("deck_id", deck_id);
      await sb.from("deck_tags").insert({ deck_id, theme: (themeLabel||null), tags: tagsArr, created_by_session: sid });
      return true;
    }catch{}
  }
  return false;
}

/* ===== 登録 ===== */
$("#regBtn").addEventListener("click", async ()=>{
  const msg=$("#regMsg"); msg.textContent="";
  const v=$("#regUrl").value.trim(); const url=canonUrl(v);
  if(!url){ msg.textContent="URL形式が正しくありません。"; return; }

  // 先に公開チェック
  msg.textContent="検証中...";
  try{ await validateHareruya(url); }
  catch(e){
    const code = String(e?.message || e);
    if (code === "deck_private")   { msg.textContent="非公開/限定公開です。晴れる屋側で『全員に公開』にしてください。"; return; }
    if (code === "deck_not_found") { msg.textContent="ページが見つかりません（削除/URL間違いの可能性）。"; return; }
    msg.textContent="現在このURLは登録できません。"; return;
  }

  // 登録
  msg.textContent="登録中...";
  try{
    const res = await fetch(FN_INGEST,{
      method:"POST",
      headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON },
      body: JSON.stringify({ url, session_id:sid })
    });
    const j = await res.json().catch(()=> ({}));

    // 409（already_registered）なら既存行をそのまま表示
    if (res.status === 409 || j?.error === 'already_registered') {
      msg.textContent = "このデッキは既に登録されています。検索から開いてください。";
      if (j?.data?.id) { await showDeckByRow(j.data, { showResults: true }); return; }
      try {
        const existing = await findDeckByUrlOrId(url);
        if (existing) { await showDeckByRow(existing, { showResults: true }); return; }
      } catch {}
      msg.textContent = "既に登録済みですが、取得できませんでした（already_registered_but_not_readable）。";
      return;
    }

    // 新規作成成功
    if (res.ok && j?.ok && j?.data?.id) {
      const deckRow = j.data;

      // UI: タグ保存
      const theme = regThemeSel.value || null;
      const tags  = [...regChosen];
      await saveTagsForDeck(deckRow.id, theme, tags);

      msg.textContent = "登録しました。";
      try{ await showDeckByRow(deckRow,{showResults:false}); }catch{}
      loadMine();
      return;
    }

    msg.textContent = `登録失敗: ${j?.error || res.statusText}`;
  }catch{
    msg.textContent="登録に失敗しました。";
  }
});

/* ===== 通報タブ ===== */
$("#delBtn").addEventListener("click", async ()=>{
  const msg=$("#delMsg"); msg.textContent="";
  const v=$("#delUrl").value.trim(); const url=canonUrl(v); if(!url){ msg.textContent="URL形式が正しくありません。"; return; }
  const { data } = await sb.from("decks").select("id").eq("source_url", url).maybeSingle();
  if(!data?.id){ msg.textContent="まだ登録されていない可能性があります。"; return; }
  try{
    const res = await fetch(FN_REPORT,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: data.id, session_id: sid, reason:"user_delete_request" }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j?.ok!==false){ msg.textContent="報告を受け付けました。ありがとうございました。"; }
    else{ msg.textContent=`報告に失敗しました: ${j?.error || res.statusText}`; }
  }catch{ msg.textContent="報告に失敗しました。"; }
});

/* ===== 自分の登録 ===== */
$("#reloadMine").addEventListener("click", ()=> loadMine());

async function openTagsModal(deck_id){
  // 表示値を「ラベル」で保持
  let theme = null, tags = [];

  // 旧スキーマ（先に簡単な方）
  try{
    const q = await sb.from("deck_tags").select("theme,tags").eq("deck_id", deck_id).maybeSingle();
    if (!q.error && q.data){
      theme = q.data.theme || null;
      tags  = Array.isArray(q.data.tags) ? q.data.tags : [];
    }
  }catch{}

  // 新スキーマ
  if (theme===null && tags.length===0){
    try{
      const [deckRow, tagRows] = await Promise.all([
        sb.from("decks").select("theme_key").eq("id", deck_id).maybeSingle(),
        sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id).limit(100)
      ]);
      const tkey  = deckRow?.data?.theme_key || null;
      const tkeys = (tagRows?.data||[]).map(r=>r?.tag_key).filter(Boolean);
      const all   = [...new Set([tkey, ...tkeys].filter(Boolean))];
      if (all.length){
        const { data: masters } = await sb
          .from("app_tags_master").select("key,label,kind").in("key", all).limit(500);

        const toLabel = (k)=> (masters||[]).find(m=>m.key===k)?.label || k;

        theme = tkey ? toLabel(tkey) : null;

        if (!theme){
          const tFromTags = (masters||[]).find(m => m.kind==="theme" && tkeys.includes(m.key));
          if (tFromTags) theme = tFromTags.label || tFromTags.key;
        }

        const themeKeyResolved = (masters||[]).find(m => (m.label===theme || m.key===theme))?.key ?? null;
        tags = tkeys
          .filter(k => k !== themeKeyResolved)
          .map(toLabel);
      }
    }catch{}
  }

  // ===== UI =====
  const body = document.createElement("div");

  const cap1 = Object.assign(document.createElement("div"), { textContent:"デッキの狙い（1つ）" });
  cap1.className = "note"; cap1.style.margin = "6px 0 4px";

  const sel = document.createElement("select");
  sel.innerHTML = `<option value="">未選択</option>`;
  if (theme && !MASTER.themes.includes(theme)){
    sel.insertAdjacentHTML("beforeend", `<option value="${theme}">${theme}</option>`);
  }
  sel.insertAdjacentHTML("beforeend", MASTER.themes.map(v=> `<option value="${v}">${v}</option>`).join(""));
  const choose = (selectEl, valueOrText) => {
    const want = String(valueOrText ?? "").trim();
    if (!want){ selectEl.value=""; return; }
    selectEl.value = want;
    if (selectEl.value !== want){
      const opt = Array.from(selectEl.options).find(o => String(o.textContent).trim() === want);
      if (opt){ opt.selected = true; }
    }
  };
  choose(sel, theme);
  body.append(cap1, sel);

  const cap2 = Object.assign(document.createElement("div"), { textContent:"タグ（最大3つ）" });
  cap2.className="note"; cap2.style.margin = "10px 0 4px";

  const box = document.createElement("div"); box.className="row";
  const chosen = new Set((Array.isArray(tags)? tags: []).map(String));

  function refreshLock(){
    const lock = chosen.size >= 3;
    for(const b of box.querySelectorAll(".chip-sel")){
      if(!b.classList.contains("on")){ b.disabled = lock; b.style.opacity = lock ? ".6" : "1"; }
    }
  }

  const tagUniverse = [...new Set([ ...MASTER.tags, ...chosen ])];
  for(const t of tagUniverse){
    const b = document.createElement("button");
    b.type="button";
    b.className = "chip-sel" + (chosen.has(t) ? " on" : "");
    b.textContent = t;
    b.addEventListener("click", ()=>{
      if(!b.classList.contains("on") && chosen.size>=3) return;
      b.classList.toggle("on");
      if(b.classList.contains("on")) chosen.add(t); else chosen.delete(t);
      refreshLock();
    });
    box.appendChild(b);
  }
  refreshLock();
  body.append(cap2, box);

  openModal("タグ編集", body, true, async ()=>{
    const ok = await saveTagsForDeck(deck_id, (sel.value||null), [...chosen]);
    if(ok){ toast("保存しました"); closeModal(); await showDeckTags(deck_id); }
    else{ toast("保存に失敗しました"); }
  });
}

async function openReasonsModal(deck_id){
  let rows = [];

  // 1) label_reasons 直読 → JS集計
  try{
    const { data: list, error } = await sb
      .from("label_reasons")
      .select("reason_key")
      .eq("deck_id", deck_id)
      .limit(10000);
    if(!error && Array.isArray(list)){
      const m = new Map();
      for(const r of list){ const k=(r?.reason_key||"その他"); m.set(k,(m.get(k)||0)+1); }
      rows = [...m.entries()].map(([key,cnt])=>({key,cnt})).sort((a,b)=>b.cnt-a.cnt).slice(0,50);
    }
  }catch{}

  // キー→ラベル解決
  if (rows.length){
    let labelMap = new Map(REASONS_MASTER.map(r=>[r.key, r.label]));
    if (!labelMap.size){
      try{
        const r = await sb.from("app_reasons_master").select("key,label").in("key", rows.map(x=>x.key));
        if (!r.error && r.data?.length) labelMap = new Map(r.data.map(x=>[String(x.key), String(x.label||x.key)]));
      }catch{}
    }
    rows = rows.map(x => ({ reason: labelMap.get(String(x.key)) || String(x.key), cnt: x.cnt }));
  }

  // ===== 表示 =====
  const body = document.createElement("div");
  if(rows.length===0){
    body.textContent = "まだ理由がありません。";
  }else{
    for(const r of rows){
      const line = document.createElement("div");
      line.style.display="flex";
      line.style.justifyContent="space-between";
      line.style.padding="4px 0";
      line.innerHTML = `<span>${r.reason}</span><b>${r.cnt}</b>`;
      body.appendChild(line);
    }
  }
  openModal("投票理由（上位）", body, false, null);
}

async function loadMine(){
  const listEl=$("#mineList");
  listEl.innerHTML="読み込み中…";
  const { data, error } = await sb.from("decks")
    .select("id,source_url,deck_name,created_at")
    .eq("created_by_session", sid)
    .order("created_at",{ascending:false})
    .limit(50);
  if(error){ listEl.textContent="読み込みエラー"; return; }
  if(!data || data.length===0){ listEl.textContent="まだ登録がありません。"; return; }

  const ids = data.map(d=>d.id);
  const countsMap = {};
  try{
    if(ids.length){
      const { data: agg, error: aggErr } = await sb.rpc('labels_counts_by_deck_many', { p_decks: ids, p_min_rt: 5, p_include_null:true });
      if(!aggErr && Array.isArray(agg)){
        for(const r of agg){
          const arr = countsMap[r.deck_id] || (countsMap[r.deck_id]=[0,0,0,0]);
          const i = (r.bracket|0) - 1; if(i>=0 && i<4) arr[i] = Number(r.cnt) || 0;
        }
      }
    }
  }catch{}
  if(Object.keys(countsMap).length===0){
    for(const d of data){
      try{
        const { data: rows } = await sb.from("labels").select("bracket,rt_sec").eq("deck_id", d.id).limit(10000);
        const arr=[0,0,0,0];
        for(const r of (rows||[])){ if(passRtFilter(r.rt_sec)){ const i=(r.bracket|0)-1; if(i>=0&&i<4) arr[i]++; } }
        countsMap[d.id]=arr;
      }catch{ countsMap[d.id]=[0,0,0,0]; }
    }
  }

  listEl.innerHTML="";
  for(const d of data){
    const idNum = toDeckId(d.source_url) || d.id;
    const item=document.createElement("div"); item.className="item";

    const a=document.createElement("a");
    a.href=d.source_url; a.target="_blank"; a.rel="noopener noreferrer"; a.textContent = idNum;

    const wrap=document.createElement("div"); wrap.className="mini-wrap";
    const [c1,c2,c3,c4] = countsMap[d.id] || [0,0,0,0];
    wrap.append( makeMiniBar(c1,c2,c3,c4) );

    const show=document.createElement("button"); show.className="small-btn"; show.textContent="表示"; show.type="button";
    show.addEventListener("click", async ()=> {
      const row = await sb.from("decks").select("id,source_url,deck_name,registered_at").eq("id", d.id).maybeSingle();
      if(row.data) await showDeckByRow(row.data,{showResults:false});
      closeSheet();
    });

    const reasonBtn=document.createElement("button"); reasonBtn.className="small-btn"; reasonBtn.textContent="投票理由"; reasonBtn.type="button";
    reasonBtn.addEventListener("click", ()=> openReasonsModal(d.id));

    const tagBtn=document.createElement("button"); tagBtn.className="small-btn"; tagBtn.textContent="タグ編集"; tagBtn.type="button";
    tagBtn.addEventListener("click", ()=> openTagsModal(d.id));

    const del=document.createElement("button"); del.className="small-btn"; del.textContent="削除"; del.type="button";
    del.addEventListener("click", ()=> deleteOwn(d.id, item));

    item.append(a, wrap, show, reasonBtn, tagBtn, del);
    listEl.appendChild(item);
  }
}

/* 削除：ダミーEdgeは呼ばず、RPC→直書きの順にフォールバック */
async function deleteOwn(deck_id, node){
  if(!confirm("この登録を削除しますか？（投票/通報も削除されます）")) return;

  try{
    const r = await sb.rpc('delete_own_deck', { p_deck: deck_id, p_session: sid });
    if(!r.error){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  try{
    const d = await sb.from("decks").delete().eq("id", deck_id).eq("created_by_session", sid);
    if(!d.error){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  toast("削除に失敗しました。");
}

/* ===== 起動 ===== */
updateXpUI();
const paramDeck = new URLSearchParams(location.search).get("deck");
if (paramDeck) {
  const url = canonUrl(paramDeck);
  if (url) {
    try { const row = await ensureDeckExists(url); await showDeckByRow(row, { showResults: true }); }
    catch { await loadRandomDeck(); }
  } else { await loadRandomDeck(); }
} else { await loadRandomDeck(); }

// キーボードショートカット
window.addEventListener('keydown', (e)=>{
  const tag = document.activeElement?.tagName;
  if (tag === 'INPUT' || tag === 'TEXTAREA') return;
  if (['1','2','3','4'].includes(e.key)) {
    document.querySelector(`.chip[data-vote="${e.key}"]`)?.click();
  } else if (e.key.toLowerCase()==='s') {
    document.getElementById('skipBtn')?.click();
  } else if (e.key.toLowerCase()==='n') {
    document.getElementById('nextBtn')?.click();
  }
});

// type保険
for (const b of document.querySelectorAll('button:not([type])')) b.setAttribute('type','button');

// ミニグラフ
function makeMiniBar(c1,c2,c3,c4){
  const total = Math.max(0, (c1|0)+(c2|0)+(c3|0)+(c4|0));
  const per = total ? [c1/total*100,c2/total*100,c3/total*100,c4/total*100] : [0,0,0,0];
  const bar = document.createElement('div'); bar.className='mini-bar';
  const s1=document.createElement('div'); s1.className='mini-seg b1'; s1.style.left='0%'; s1.style.width=per[0]+'%';
  const s2=document.createElement('div'); s2.className='mini-seg b2'; s2.style.left=per[0]+'%'; s2.style.width=per[1]+'%';
  const s3=document.createElement('div'); s3.className='mini-seg b3'; s3.style.left=(per[0]+per[1])+'%'; s3.style.width=per[2]+'%';
  const s4=document.createElement('div'); s4.className='mini-seg b4'; s4.style.left=(per[0]+per[1]+per[2])+'%'; s4.style.width=per[3]+'%';
  const ov=document.createElement('div'); ov.className='mini-overlay';
  const label = total ? `1 ${Math.round(per[0])}% ・ 2 ${Math.round(per[1])}% ・ 3 ${Math.round(per[2])}% ・ 4 ${Math.round(per[3])}%` : '投票なし';
  ov.textContent = label; bar.title = label;
  bar.append(s1,s2,s3,s4,ov);
  return bar;
}

</script>
</body>
</html>
