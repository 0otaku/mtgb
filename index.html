<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>みんなでブラケット診断</title>

<link rel="preconnect" href="https://esm.sh" crossorigin>
<link rel="preconnect" href="https://www.hareruyamtg.com" crossorigin>
<link rel="dns-prefetch" href="//www.hareruyamtg.com">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 16 16%27><circle cx=%278%27 cy=%278%27 r=%273%27/></svg>">

<style>

:root{
  --bg:#fff; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb;
  --brand:#d62828; --c1:#6EE7B7; --c2:#93C5FD; --c3:#FDE68A; --c4:#FCA5A5;
  --radius:14px; --accent:#6366f1; --accent2:#8b5cf6;
}
*{box-sizing:border-box} html,body{height:100%}
body{margin:0;font-family:"Inter","Noto Sans JP",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--fg);background:var(--bg)}
.wrap{max-width:1200px;margin:0 auto;padding:16px}

/* header */
header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px 0 12px}
.title{display:flex;flex-direction:column;gap:4px;min-width:0}
.site{font-weight:800;letter-spacing:.01em;font-size:20px}
@media(min-width:1000px){ .site{font-size:24px} }
.deck-meta{display:flex;align-items:center;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:13px}
.deck-link{color:#2563eb;text-decoration:underline;text-underline-offset:2px}

/* デッキタグ（タイトル右） */
.tag-chips{display:inline-flex;gap:6px;flex-wrap:wrap}
.tagchip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);padding:4px 8px;border-radius:999px;background:#fff;color:#374151;font-size:12px;white-space:nowrap}
.tagchip.theme{border-color:#c7d2fe;background:#eef2ff}  /* indigo系 */
.tagchip.free{border-color:#e5e7eb;background:#f9fafb}

/* 汎用ボタン */
.small-btn{font-size:13px;border:1px solid var(--border);background:#fff;color:#374151;border-radius:999px;padding:6px 12px;cursor:pointer}
.small-btn:hover{background:#fafafa}
.small-btn.primary{background:#111;border-color:#111;color:#fff}
.small-btn.subtle{opacity:.82}
.small-btn.subtle:hover{opacity:1}

.card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);padding:16px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
.grid{display:grid;gap:16px}
@media(min-width:1000px){ .grid{grid-template-columns:1.2fr .8fr} }

/* 埋め込み */
.embed-wrap{position:relative;background:#fff;border-radius:var(--radius);overflow:hidden;border:1px solid var(--border)}
iframe{width:100%;height:70vh;min-height:520px;border:0;display:block;background:#fff}
.overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(255,255,255,.94), rgba(255,255,255,.94));text-align:center;padding:18px}
.overlay .box{max-width:560px}
.overlay .box h3{margin:0 0 8px;font-size:18px}
.overlay .box p{margin:6px 0;color:#4b5563;font-size:14px}
.overlay .box .row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:10px}
.overlay .box a, .overlay .box button{border:1px solid var(--border);border-radius:10px;padding:10px 12px;background:#fff;cursor:pointer;font-size:14px}

/* 投票 */
.vote-card{display:flex;flex-direction:column;gap:12px}
.vote-block{padding:12px;border:1px dashed var(--border);border-radius:14px;background:#fafafa}
.prompt{font-weight:800;letter-spacing:.01em;font-size:16px}
@media(min-width:1000px){ .prompt{font-size:20px} }
.vote-row{display:grid; gap:10px; grid-template-columns:1fr 1fr; margin-top:10px}
@media(min-width:1000px){ .vote-row{grid-template-columns:repeat(4,1fr)} }
.chip{width:100%; height:64px; font-size:22px; font-weight:800; border:1px solid var(--border); border-radius:12px; background:#f4f4f5; cursor:pointer; transition:transform .07s ease, background .15s ease, box-shadow .15s ease;}
.chip:hover{background:#e9e9eb}
.chip:active{transform:scale(.98)}
.b1{background:color-mix(in srgb, var(--c1) 18%, white)}
.b2{background:color-mix(in srgb, var(--c2) 18%, white)}
.b3{background:color-mix(in srgb, var(--c3) 20%, white)}
.b4{background:color-mix(in srgb, var(--c4) 20%, white)}
@media(min-width:1000px){ .chip{height:72px; font-size:24px} }
.chip.selected{ position:relative; outline:2px solid var(--brand); box-shadow:0 0 0 4px color-mix(in srgb, var(--brand) 18%, transparent) inset; transform: translateY(-1px); filter:brightness(1.03) }
.chip[disabled]{opacity:.6; pointer-events:none; filter:grayscale(.2)}

.skip-row{margin-top:6px}
.skip{font-size:12px;color:#6b7280;text-decoration:underline;background:transparent;border:0;cursor:pointer}

/* 集計バー */
.results{display:none;flex-direction:column;gap:8px}
.bar{position:relative;height:30px;border-radius:8px;background:#f3f4f6;border:1px solid #e5e7eb;overflow:hidden}
.seg{position:absolute;top:0;bottom:0}
.seg.b1{background:var(--c1)} .seg.b2{background:var(--c2)} .seg.b3{background:var(--c3)} .seg.b4{background:var(--c4)}
.legend{display:flex;gap:10px;flex-wrap:wrap;color:#374151;font-size:13px}
.legend span{display:inline-flex;align-items:center;gap:6px}
.dot{width:12px;height:12px;border-radius:999px;display:inline-block}
.hint{font-size:12px;color:var(--muted)}

.action-row{display:flex;gap:8px;align-items:center;margin-top:6px;flex-wrap:wrap}
#nextBtn{ font-weight:700; border:1px solid var(--accent); background:linear-gradient(135deg, var(--accent), var(--accent2)); color:#fff; border-radius:10px; padding:8px 12px }
#nextBtn:hover{ filter:brightness(1.03) }
#nextBtn.pulse{ animation:nextPulse 1.8s ease-in-out infinite }
@keyframes nextPulse{ 0%{box-shadow:0 0 0 0 rgba(99,102,241,.45)} 70%{box-shadow:0 0 0 12px rgba(99,102,241,0)} 100%{box-shadow:0 0 0 0 rgba(99,102,241,0)} }

/* 理由チップ（Nextの下に10秒だけ） */
.reason-wrap{display:none;gap:6px;flex-wrap:wrap;margin-top:6px}
.reason-btn{font-size:12px;line-height:1;border:1px solid var(--border);border-radius:999px;padding:6px 8px;background:#fff;cursor:pointer}
.reason-btn.on{background:#111;color:#fff;border-color:#111}

/* 検索 */
.search-card{display:flex;flex-direction:column;gap:12px}
.search-row{display:flex;gap:8px;flex-wrap:nowrap}
input[type="text"]{flex:1 1 420px; min-width:260px; padding:10px 12px; border:1px solid var(--border); border-radius:10px; font-size:14px}
#searchBtn{padding:8px 12px}

/* Mana/XP */
.mana-wrap{display:flex;align-items:center;gap:8px;margin-top:6px}
.mana-bar{flex:1;height:6px;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;overflow:hidden}
.mana-bar > i{display:block;height:100%;width:0;background:#d1d5db}
.mana-syms{display:flex;align-items:center;gap:4px;flex-wrap:wrap}
.sym{width:16px;height:16px;border-radius:999px;border:1px solid #e5e7eb;display:inline-flex;align-items:center;justify-content:center;font-size:11px;line-height:1;background:#fff}
.sym.W{background:#fefce8;border-color:#fde68a}
.sym.U{background:#eff6ff;border-color:#bfdbfe}
.sym.B{background:#f5f5f5;border-color:#d4d4d4}
.sym.R{background:#fee2e2;border-color:#fecaca}
.sym.G{background:#ecfdf5;border-color:#bbf7d0}
.sym.C{background:#f3f4f6;border-color:#e5e7eb}
.rt{font-size:12px;color:#9ca3af;margin-left:6px}

/* トースト */
.toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#111;color:#fff;padding:10px 14px;border-radius:999px;display:none;z-index:50}

/* 右シート */
.sheet-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none}
.sheet{position:fixed;right:0;top:0;bottom:0;width:min(520px,100%);background:#fff;box-shadow:-10px 0 30px rgba(0,0,0,.2);display:none;flex-direction:column}
.sheet header{padding:16px;border-bottom:1px solid var(--border)}
.sheet .body{padding:16px;display:flex;flex-direction:column;gap:12px;overflow:auto;max-height:calc(100vh - 56px)}
.tabs{display:flex;gap:8px;flex-wrap:wrap}
.tab{padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;cursor:pointer;font-size:13px}
.tab.active{background:#111;border-color:#111;color:#fff}
.note{font-size:12px;color:var(--muted);line-height:1.6}
.msg{font-size:14px}
.item{display:flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:10px;padding:8px}
.item a{color:#111;text-decoration:none}
.item a:hover{text-decoration:underline}

/* ミニグラフ */
.mini-wrap{flex:1; display:flex; align-items:center; gap:8px}
.mini-bar{ position:relative; height:18px; width:100%; background:#f3f4f6; border:1px solid #e5e7eb; border-radius:4px; overflow:hidden; }
.mini-seg{position:absolute; top:0; bottom:0}
.mini-seg.b1{background:var(--c1)} .mini-seg.b2{background:var(--c2)}
.mini-seg.b3{background:var(--c3)} .mini-seg.b4{background:var(--c4)}
.mini-overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:12px; line-height:1; padding:0 6px; color:#111; background:rgba(255,255,255,.86); opacity:0; transition:opacity .15s; }
.mini-bar:hover .mini-overlay{opacity:1}

/* 選択チップ（登録/タグ編集UI） */
.chip-sel{border:1px solid var(--border);border-radius:999px;background:#fff;padding:6px 8px;font-size:12px;cursor:pointer;margin:2px}
.chip-sel.on{background:#111;color:#fff;border-color:#111}

/* Xボタン */
.xbtn{display:inline-flex;align-items:center;gap:6px;font-weight:700;background:#000;color:#fff;border:1px solid #000;border-radius:999px;padding:7px 12px;white-space:nowrap}
.xbtn svg{width:14px;height:14px;flex:0 0 auto}

/* 簡易モーダル */
.modal-back{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;z-index:60}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(560px,92vw);background:#fff;border:1px solid var(--border);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);display:none;flex-direction:column;z-index:61}
.modal header{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal .body{padding:12px 14px;max-height:60vh;overflow:auto}
.modal .foot{display:flex;gap:8px;justify-content:flex-end;padding:12px 14px;border-top:1px solid var(--border)}

/* ====== 見た目を小さく控えめに（上書き） ====== */

/* ヘッダー右の表示タグ */
.tag-chips{ gap:4px; }
.tagchip{
  font-size:11px;               /* 小さく */
  padding:2px 6px;              /* 薄く */
  border-radius:6px;           /* 角Rも控えめ */
  line-height:1.2;
  background:#fafafa;
  border-color:#e6e6e6;
  color:#475569;
}
.tagchip.theme{
  background:#f6f8ff;
  border-color:#dbe4ff;
}

/* 登録/編集モーダルの選択チップ */
.chip-sel{
  font-size:11px;
  padding:5px 8px;
  border-radius:12px;
}

/* スマホではさらに控えめ */
@media (max-width: 680px){
  .tagchip{ font-size:10px; padding:2px 5px; border-radius:4px; }
  .chip-sel{ font-size:10px; padding:4px 6px; border-radius:4px; }
  .tag-chips{ gap:3px; }
}

/* === ヘッダー右ボタンをモバイルで小さく・同一行に収める === */
header { align-items: center; }
.title { flex: 1 1 auto; min-width: 0; }   /* 左側を可変で広げる */
#openSheet { flex: 0 0 auto; white-space: nowrap; }

@media (max-width: 680px){
  #openSheet{
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 8px;
    line-height: 1.1;
  }
  .site{ font-size: 18px; }                 /* タイトルも少しだけ詰める */
  .deck-meta{ font-size: 12px; gap: 8px; }  /* メタ行をコンパクトに */
}

/* テーマタグを控えめ強調（背景ちょい濃い & 枠色も少し強め） */
.tagchip.theme{
  /* Fallback（color-mix未対応ブラウザ用） */
  background:#eef2ff;         /* 元の #f6f8ff より少しだけ濃い */
  border-color:#cfd8ff;

  /* 主要ブラウザ用：サイトのアクセント色をほんのり混ぜる */
  background: color-mix(in srgb, var(--accent) 16%, white);
  border-color: color-mix(in srgb, var(--accent) 42%, white);

  /* うるさくならない程度の内側ハイライト（任意） */
  box-shadow: inset 0 0 0 1px rgba(99,102,241,.04);
}

/* ===== SPレイアウト: 右上にボタン固定 + タグ4個を横一列 ===== */
@media (max-width: 680px){
  /* headerを2カラムに（左：タイトル/タグ、右：ボタン） */
  header{
    position: relative;
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: start;
    gap: 8px;
  }
  #openSheet{
    justify-self: end;
    align-self: start;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 8px;
    line-height: 1.1;
  }
  .title{ min-width: 0; }          /* 左カラムを縮められるように */
  .deck-meta{
    display: flex;
    align-items: center;
    gap: 6px;
    min-width: 0;
  }

/* ===== SP: ボタンは右上に固定、タグは自動幅＋必要なら改行 ===== */
@media (max-width: 680px){
  header{
    position: relative;
    display: block;
  }
  #openSheet{
    position: absolute;
    top: 6px;
    right: 8px;
    font-size: 12px;
    padding: 4px 8px;
    border-radius: 8px;
    line-height: 1.1;
    z-index: 1;
  }

  /* タグ列は全幅を使い、入らなければ折り返す */
  #deckTags.tag-chips{
    display: flex;
    flex-wrap: wrap;             /* ← ここで改行OKに */
    gap: 4px;
    width: 100%;
    overflow: visible;
  }
  #deckTags .tagchip{
    flex: 0 0 auto;              /* 均等幅を解除＝自動幅 */
    max-width: 100%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;     /* 長いラベルは省略表示 */
  }
}

</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <a href="./" class="site" style="color:inherit;text-decoration:none">みんなでブラケット診断</a>
      <div class="deck-meta">
        <a class="deck-link" data-deck-title target="_blank" rel="noopener">#0000000</a>
        <span id="deckTags" class="tag-chips"></span>
      </div>
    </div>
    <button id="openSheet" class="small-btn">登録 / 確認</button>
  </header>

  <div class="grid">
    <div class="embed-wrap card">
      <iframe id="deckFrame" title="Hareruya Deck"
              sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation"
              loading="eager"></iframe>

      <div class="overlay" id="embedFail">
        <div class="box">
          <h3>ページを表示できませんでした</h3>
          <p>ブラウザや拡張機能の制限で埋め込みがブロックされる場合があります。下のリンクから新しいタブで開いてください。</p>
          <div class="row">
            <a id="openHareruyaLink" target="_blank" rel="noopener noreferrer">hareruyamtg.com で開く</a>
            <button id="retryEmbed">再読み込み</button>
          </div>
          <p class="note" style="margin-top:10px">※ iOS/Safariの場合、トラッキング防止/コンテンツブロッカー設定により表示されないことがあります。</p>
        </div>
      </div>
    </div>

    <div class="card vote-card">
      <div class="vote-block">
        <div class="prompt">このデッキのブラケットは？</div>
        <div class="vote-row">
          <button class="chip b1" data-vote="1" aria-pressed="false">１</button>
          <button class="chip b2" data-vote="2" aria-pressed="false">２</button>
          <button class="chip b3" data-vote="3" aria-pressed="false">３</button>
          <button class="chip b4" data-vote="4" aria-pressed="false">４</button>
        </div>
        <div class="skip-row">
          <button class="skip" id="skipBtn" title="このデッキは評価しない">回答しない</button>
        </div>
        <div class="hint">※ 同じデッキは1つだけ記録（変更可）</div>
      </div>

      <div class="results" id="results">
        <div class="bar" aria-label="集計バー">
          <div class="seg b1" id="seg1" style="left:0;width:0%"></div>
          <div class="seg b2" id="seg2" style="left:0;width:0%"></div>
          <div class="seg b3" id="seg3" style="left:0;width:0%"></div>
          <div class="seg b4" id="seg4" style="left:0;width:0%"></div>
        </div>
        <div class="legend">
          <span><i class="dot" style="background:var(--c1)"></i> 1 <b id="p1">0%</b></span>
          <span><i class="dot" style="background:var(--c2)"></i> 2 <b id="p2">0%</b></span>
          <span><i class="dot" style="background:var(--c3)"></i> 3 <b id="p3">0%</b></span>
          <span><i class="dot" style="background:var(--c4)"></i> 4 <b id="p4">0%</b></span>
        </div>

        <div class="action-row">
          <button id="nextBtn" class="small-btn primary">次のデッキへ</button>
          <span class="hint" id="autoNextHint" aria-live="polite"></span>
        </div>

        <!-- 理由チップ（10秒表示） -->
        <div id="reasonPanel" class="reason-wrap"></div>
      </div>

      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="shareBtn" class="xbtn" title="シェア">
          <svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M18.244 2H21l-6.52 7.455L22 22h-6.843l-4.68-6.105L4.96 22H2.2l7.06-8.07L2 2h6.94l4.26 5.64L18.244 2Zm-1.197 18.4h1.83L7.03 3.52H5.09l11.958 16.88Z"/></svg>
          シェア
        </button>
        <button id="reportBtn" class="small-btn">削除希望</button>
      </div>

      <!-- Mana/XP -->
      <div class="mana-wrap" style="position:relative">
        <div id="manaSyms" class="mana-syms" aria-label="獲得マナ"></div>
        <div class="mana-bar"><i id="manaFill" style="width:0%"></i></div>
        <span class="rt" id="rtLabel" style="display:none">0sec</span>
      </div>
    </div>
  </div>

  <div class="card search-card" style="margin-top:16px">
    <div class="search-row">
      <input type="text" id="searchInput" placeholder="例: https://www.hareruyamtg.com/decks/0000000  または 0000000" aria-label="デッキ検索入力欄">
      <button id="searchBtn" class="small-btn">検索</button>
    </div>
  </div>

  <footer class="card" style="margin-top:16px">
    <div class="note">
      ※ 本サイトは外部サイトのページを埋め込み表示します。掲載URLはユーザー投稿であり、
      内容の正確性・合法性を保証しません。著作権等の権利は各権利者に帰属します。
      不適切・権利侵害の疑いがあるURLは「削除希望」からご連絡ください。必要に応じて削除対応します。
    </div>
  </footer>
</div>

<!-- 右シート -->
<div class="sheet-backdrop" id="backdrop"></div>
<aside class="sheet" id="sheet" aria-modal="true" role="dialog">
  <header>
    <div style="font-weight:700">登録 / 確認</div>
    <button id="closeSheet" class="small-btn right">閉じる</button>
  </header>
  <div class="body">
    <div class="tabs" role="tablist">
  <button class="tab active" data-tab="reg"  role="tab" aria-selected="true">登録</button>
  <button class="tab"         data-tab="mine" role="tab" aria-selected="false">自分のデッキ</button>
  <button class="tab"         data-tab="del"  role="tab" aria-selected="false">削除依頼</button>
</div>


    <div id="pane-reg">
      <div class="note">
        晴れる屋デッキのURL（または数字ID）を入力して「登録」<br>
        <b>※公開範囲は「全員に公開」に設定してください。</b>
      </div>
      <div class="search-row">
        <input type="text" id="regUrl" placeholder="例: https://www.hareruyamtg.com/decks/0000000">
        <button id="regBtn" class="small-btn">登録</button>
      </div>

      <!-- ▼ 追加：登録時のタグ入力（任意 / 自由タグは最大3件） -->
      <div style="margin-top:10px">
        <div class="note" style="margin-bottom:6px">任意でタグを付けられます（変更可）</div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <label for="regTheme" class="note">デッキの狙い:</label>
          <select id="regTheme"></select>
        </div>
        <div class="note" style="margin:6px 0 4px">タグ（最大3つ / 複数可）:</div>
        <div id="regTagBox" style="display:flex;flex-wrap:wrap"></div>
        <div id="regTagHint" class="note"></div>
      </div>

      <div class="msg" id="regMsg"></div>
    </div>

    <div id="pane-del" style="display:none">
      <div class="note">削除してほしいデッキのURL（または数字ID）を入力して「通報」。一定数で自動削除。</div>
      <div class="search-row">
        <input type="text" id="delUrl" placeholder="例: https://www.hareruyamtg.com/decks/0000000">
        <button id="delBtn" class="small-btn">通報</button>
      </div>
      <div class="msg" id="delMsg"></div>
    </div>

    <div id="pane-mine" style="display:none">
      <div class="note">あなたが登録したデッキ一覧（最大50件）。ここから削除できます。</div>
      <div style="display:flex;gap:8px;margin-bottom:6px">
        <button id="reloadMine" class="small-btn">更新</button>
      </div>
      <div id="mineList" style="display:flex;flex-direction:column;gap:8px"></div>
    </div>
  </div>
</aside>

<!-- 簡易モーダル（理由一覧 / タグ編集で使用） -->
<div id="modalBack" class="modal-back"></div>
<div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <header>
    <div id="modalTitle" style="font-weight:700">Title</div>
    <button id="modalClose" class="small-btn">閉じる</button>
  </header>
  <div id="modalBody" class="body"></div>
  <div class="foot">
    <button id="modalSave" class="small-btn primary" style="display:none">保存</button>
  </div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* ===== Supabase 設定 ===== */
const SUPABASE_URL  = "https://onzljxnqlrohkzsfxqbh.supabase.co";
const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9uemxqeG5xbHJvaGt6c2Z4cWJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU1NzUzNTksImV4cCI6MjA3MTE1MTM1OX0.eLAP_-PtVm6tBFFCNfOVsTqEcvtZK3x3QFFNeRpxuj8";
const FN_INGEST     = `${SUPABASE_URL}/functions/v1/ingest-hareruya`;
const FN_REPORT     = `${SUPABASE_URL}/functions/v1/report-deck`;
const FN_DELETE_OWN = `${SUPABASE_URL}/functions/v1/delete-own-deck`;
const FN_VOTE       = `${SUPABASE_URL}/functions/v1/vote`;
const FN_SKIP       = `${SUPABASE_URL}/functions/v1/skip`;
/* タグ/理由（あるならEdge/テーブルから取得、無ければハードコードにフォールバック） */
const FN_SET_TAGS   = `${SUPABASE_URL}/functions/v1/set-tags`;
const FN_GET_TAGS   = `${SUPABASE_URL}/functions/v1/get-tags`;
const FN_REASON_ADD = `${SUPABASE_URL}/functions/v1/reason-add`;
const FN_REASON_SUM = `${SUPABASE_URL}/functions/v1/reason-sum`;
const APP_URL       = `${location.origin}${location.pathname}`;

// ===== Supabase 設定 =====
const sb = createClient(SUPABASE_URL, SUPABASE_ANON, {
  auth: { persistSession:false, autoRefreshToken:false },
  global: { headers: { apikey: SUPABASE_ANON } }
});

// 旧/新スキーマを一度だけ判定してキャッシュ（createClient の直後に置く）
const __SCHEMA = { kind: null };
async function detectSchema(){
  if (__SCHEMA.kind) return __SCHEMA.kind;
  try{
    const q = await sb.from("deck_tags").select("tag_key").limit(1);
    if (!q.error) { __SCHEMA.kind = "new"; return "new"; }
  }catch{}
  __SCHEMA.kind = "old"; return "old";
}

/* ===== Util ===== */
const $ = (q)=>document.querySelector(q);
const toastEl = $("#toast");
function toast(msg){ try{ toastEl.textContent=msg; toastEl.style.display="block"; clearTimeout(toastEl._t); toastEl._t=setTimeout(()=>toastEl.style.display="none", 1600);}catch{} }
const sid = (localStorage.getItem("sid") || (crypto?.randomUUID?.() ? crypto.randomUUID() : String(Math.random()).slice(2)+"-"+Date.now()));
localStorage.setItem("sid", sid);
function toDeckId(input){
  const s = String(input||"").trim();
  return s.match(/decks\/(\d+)/)?.[1]
      || s.match(/deck\.hareruyamtg\.com\/(\d+)/)?.[1]
      || (/^\d{4,}$/.test(s) ? s : null);
}
function canonUrl(input){ const id = toDeckId(input); return id ? `https://www.hareruyamtg.com/decks/${id}` : null; }

/* ===== log_impression: 互換ヘルパー ===== */
async function safeLogImpression(deckId){
  // v2: 引数名 p_session / p_deck
  try{
    const r = await sb.rpc("log_impression", { p_session: sid, p_deck: deckId });
    if(!r.error) return;        // ここで通れば終了
  }catch{}

  // v1: 引数名 session_id / deck_id
  try{
    await sb.rpc("log_impression", { session_id: sid, deck_id: deckId });
  }catch{}
}

/* ===== マスター（テーマ/タグ/理由） ===== */
/* デフォルト（フォールバック） */
let MASTER = {
  themes: ["コンボ","コンセプト","殴り","コントロール","スタックス","墓地利用","トークン","テンポ","ミッドレンジ","ランプ","その他"],
  tags:   ["部族","ブリンク","カウンター","トークン","墓地利用","ライフゲイン","宝物","ランプ","ロック","妨害","ヘイトベアー","増殖","コピー","装備品","打消し多め","速攻","全体除去","エンチャント多め","アーティファクト多め","多色","単色","二色","三色","５色","部族：エルフ","部族：ゴブリン","部族：人間","部族：スピリット","フレーバー重視"],
  reasons:["統率者","除去","カウンター","マナ基盤","ロック","ゲームチェンジャー","安定性","コンボ","テーマ","面白さ","フレーバー","速度","カードパワー","シナジー","色"]
};

/* masters_public が無くても 404 を出さない安全ローダー */
async function ensureMasters(){
  try {
    // 1) テーブル直読（テストでも本番でも存在しやすい）
    const tm = await sb.from("app_tags_master").select("kind,key,label").limit(1000);
    if (!tm.error && Array.isArray(tm.data) && tm.data.length) {
      const themes = tm.data.filter(x=>x.kind==="theme").map(x=>x.label || x.key);
      const tags   = tm.data.filter(x=>x.kind==="tag").map(x=>x.label || x.key);
      if (themes.length) MASTER.themes = themes;
      if (tags.length)   MASTER.tags   = tags;
    }
  } catch {}

  try {
    const rm = await sb.from("app_reasons_master").select("key,label").limit(1000);
    if (!rm.error && Array.isArray(rm.data) && rm.data.length) {
      MASTER.reasons = rm.data.map(x=>x.label || x.key);
    }
  } catch {}

  // 2) 直読で空だった場合のみ masters_public を試す（存在しなければ何もしない）
  if (!MASTER.themes?.length || !MASTER.tags?.length || !MASTER.reasons?.length) {
    try{
      const { data } = await sb.from("masters_public").select("themes,tags,reasons").limit(1).maybeSingle();
      if (data) {
        if (Array.isArray(data.themes) && data.themes.length) MASTER.themes = data.themes;
        if (Array.isArray(data.tags)   && data.tags.length)   MASTER.tags   = data.tags;
        if (Array.isArray(data.reasons)&& data.reasons.length)MASTER.reasons= data.reasons;
      }
    }catch{}
  }
}
await ensureMasters();


/* ===== 簡易モーダル ===== */
const modalBack = $("#modalBack"), modal = $("#modal"), modalTitle=$("#modalTitle"), modalBody=$("#modalBody"), modalSave=$("#modalSave");
$("#modalClose").addEventListener("click", closeModal);
modalBack.addEventListener("click", closeModal);
function openModal(title, content, saveVisible=false, onSave=null){
  modalTitle.textContent = title;
  modalBody.innerHTML = "";
  if (content instanceof HTMLElement) modalBody.replaceChildren(content);
  else modalBody.innerHTML = String(content ?? "");
  modalSave.style.display = saveVisible ? "inline-flex" : "none";
  modal.style.display = "flex"; modalBack.style.display="block";
  modalSave.onclick = saveVisible && typeof onSave==="function" ? onSave : null;
}
function closeModal(){ modal.style.display="none"; modalBack.style.display="none"; modalSave.onclick=null; }

/* ===== 埋め込み ===== */
const frame = $("#deckFrame"), fail = $("#embedFail");
const openHareruyaLink = $("#openHareruyaLink"), retryEmbed = $("#retryEmbed");
let embedWatch = null;
function setEmbed(inputUrl){
  const s = String(inputUrl || "").trim();
  const m = s.match(/decks\/(\d+)/) || s.match(/deck\.hareruyamtg\.com\/(\d+)/) || s.match(/^(\d{4,})$/);
  const id = m ? m[1] : null;
  if (!id) { frame.src = "about:blank"; fail.style.display="flex"; return; }
  const wwwUrl  = `https://www.hareruyamtg.com/decks/${id}`;
  openHareruyaLink.href = wwwUrl;
  fail.style.display="none"; frame.removeAttribute("src"); frame.src = wwwUrl;
  clearTimeout(embedWatch); embedWatch = setTimeout(()=>{ fail.style.display="flex"; }, 6000);
}
frame.addEventListener("load", ()=>{ clearTimeout(embedWatch); try{ fail.style.display="none"; }catch{} });
retryEmbed?.addEventListener("click", ()=> { if (currentDeck?.source_url) setEmbed(currentDeck.source_url); });

/* ===== 状態 ===== */
let currentDeck = null;
let autoNextTimer = null;
let deckShownAtMs = 0;
let hadMyVoteBefore = false;
let reasonXpGiven = false;

/* ===== 集計 ===== */
const resultsEl = $("#results");
const seg1=$("#seg1"), seg2=$("#seg2"), seg3=$("#seg3"), seg4=$("#seg4");
const p1=$("#p1"), p2=$("#p2"), p3=$("#p3"), p4=$("#p4");
const nextBtn=$("#nextBtn"); const autoNextHint=$("#autoNextHint");
const reasonPanel = $("#reasonPanel");

function renderChart(c1,c2,c3,c4){
  const total=Math.max(0,c1+c2+c3+c4);
  const per = total? [c1/total*100,c2/total*100,c3/total*100,c4/total*100]:[0,0,0,0];
  const l1 = 0, l2 = per[0], l3 = per[0]+per[1], l4 = per[0]+per[1]+per[2];
  seg1.style.left=l1+"%"; seg1.style.width=per[0]+"%";
  seg2.style.left=l2+"%"; seg2.style.width=per[1]+"%";
  seg3.style.left=l3+"%"; seg3.style.width=per[2]+"%";
  seg4.style.left=l4+"%"; seg4.style.width=per[3]+"%";
  p1.textContent=Math.round(per[0])+"%";
  p2.textContent=Math.round(per[1])+"%";
  p3.textContent=Math.round(per[2])+"%";
  p4.textContent=Math.round(per[3])+"%";
}

/* 5秒未満は除外。ただし「rt_sec が null/未保存」の古い投票は含める（テスト環境の過去データ対策） */
function passRtFilter(rt){ return (rt==null) || (Number(rt) >= 5); }

async function loadVotesAndRenderResults(forceShow=false){
  if(!currentDeck) return;
  let c1=0,c2=0,c3=0,c4=0;

  // 1) RPC（ある場合）
  try{
    const rpc = await sb.rpc('labels_counts_by_deck', { p_deck: currentDeck.id, p_min_rt: 5, p_include_null:true });
    if(!rpc.error && Array.isArray(rpc.data) && rpc.data.length){
      for(const r of rpc.data){
        if(r.bracket===1) c1=r.cnt|0;
        else if(r.bracket===2) c2=r.cnt|0;
        else if(r.bracket===3) c3=r.cnt|0;
        else if(r.bracket===4) c4=r.cnt|0;
      }
      renderChart(c1,c2,c3,c4);
      if(forceShow) resultsEl.style.display="flex";
      return;
    }
  }catch{}

  // 2) REST→JS集計
  try{
    const { data } = await sb.from("labels").select("bracket,rt_sec").eq("deck_id", currentDeck.id).limit(10000);
    for(const r of (data||[])){
      if (!passRtFilter(r.rt_sec)) continue;
      if(r.bracket===1)c1++; else if(r.bracket===2)c2++; else if(r.bracket===3)c3++; else if(r.bracket===4)c4++;
    }
  }catch{}
  renderChart(c1,c2,c3,c4);
  if(forceShow) resultsEl.style.display="flex";
}

/* ===== 自分の投票 ====== */
const voteChips = Array.from(document.querySelectorAll(".chip[data-vote]"));
function markMyVote(bracket){
  for(const btn of voteChips){
    const isSel = Number(btn.dataset.vote) === Number(bracket);
    btn.classList.toggle("selected", !!bracket && isSel);
    btn.setAttribute("aria-pressed", String(!!bracket && isSel));
  }
}
async function loadMyVote(){
  if(!currentDeck) { markMyVote(null); hadMyVoteBefore=false; return null; }
  const { data } = await sb.from("labels").select("bracket").eq("deck_id", currentDeck.id).eq("session_id", sid).maybeSingle();
  const b = data?.bracket ?? null;
  hadMyVoteBefore = b !== null;
  markMyVote(b);
  return b;
}

/* ===== Mana/XP ===== */
const xpKey = "xp_v3";
const manaFill=$("#manaFill"), manaSyms=$("#manaSyms"), rtLabel=$("#rtLabel");
const lvNeed = [10,30,70,150,310,630,1270,2550,5110,10230,20470,40950,81910,163830,327670,655350];
function loadXP(){ try{ return JSON.parse(localStorage.getItem(xpKey)||"{}"); }catch{ return {}; } }
function saveXP(s){ localStorage.setItem(xpKey, JSON.stringify(s)); }
function ensureXP(){
  const s = loadXP();
  if(s.xp==null) s.xp=0; if(s.lv==null) s.lv=0;
  if(!s.mana) s.mana={ C:0, W:0, U:0, B:0, R:0, G:0 };
  if(!s.hist) s.hist=[]; if(s.cp==null) s.cp=0;
  return s;
}
function circled(n){ const base = 9311; return (n>=1 && n<=20) ? String.fromCharCode(base+n) : String(n); }
function isDbl(sec){ return sec===11||sec===22||sec===33||sec===44||sec===55; }
function updateXpUI(){
  const s = ensureXP();
  const need = (s.lv ? (lvNeed[s.lv]-lvNeed[s.lv-1]) : lvNeed[0]);
  const prev = (s.lv ? lvNeed[s.lv-1] : 0);
  const cur  = Math.max(0, s.xp - prev);
  const pct  = Math.max(0, Math.min(100, need ? Math.round(cur / need * 100) : 0));
  manaFill.style.width = pct + "%";

  const order = ["C","W","U","B","R","G"];
  const syms = [];
  if ((s.mana.C||0) > 0) syms.push(`<span class="sym C">${circled(s.mana.C)}</span>`);
  for(let oi=1; oi<order.length; oi++){
    const k = order[oi];
    const cnt = s.mana[k]||0;
    for(let i=0; i<cnt; i++) syms.push(`<span class="sym ${k}">${k}</span>`);
  }
  manaSyms.innerHTML = syms.join("");
}
function pushHistory(rtSec){
  const d = new Date();
  const rec = { t:d.toISOString(), h:d.getHours(), sec:d.getSeconds(), rt:rtSec };
  const s = ensureXP(); s.hist.push(rec); saveXP(s);
}
function showManaPop(color){
  const e = document.createElement("div");
  e.className="mana-pop";
  e.innerHTML = `<span class="sym ${color}">${color==="C"?circled(1):color}</span>`;
  document.body.appendChild(e);
  setTimeout(()=>{ try{ e.remove(); }catch{} }, 900);
}
function awardManaOnLevelUp(){
  const s = ensureXP();
  const slice = s.hist.slice(s.cp);
  const last  = s.hist[s.hist.length-1] || null;

  if (last){
    if (isDbl(last.sec)){ s.mana.U = (s.mana.U||0)+1; s.cp=s.hist.length; saveXP(s); showManaPop("U"); updateXpUI(); return; }
    if ((last.sec%10)===0){ s.mana.C = (s.mana.C||0)+1; s.cp=s.hist.length; saveXP(s); showManaPop("C"); updateXpUI(); return; }
  }
  let am=0, pm=0, sum=0;
  for(const r of slice){ if(r.h<12) am++; else pm++; sum+=(r.rt||0); }
  const avg = slice.length ? (sum/slice.length) : 0;
  const isPM = pm>=am;
  let color = "C";
  if (isPM && avg<=20) color="R";
  else if (!isPM && avg>=50) color="G";
  else if (!isPM && avg>=21 && avg<=49) color="W";
  else if (isPM && avg>=21 && avg<=49) color="B";
  s.mana[color] = (s.mana[color]||0)+1; s.cp=s.hist.length; saveXP(s);
  showManaPop(color); updateXpUI();
}
function addXPIfFirstVote(rtSec, isFirst){
  const s = ensureXP();
  if (isFirst){
    s.xp = (s.xp || 0) + 1;
    const secNow = new Date().getSeconds();
    if (isDbl(secNow)) s.xp = s.xp + 1;
    saveXP(s);
  }
  const nextLvNeed = lvNeed[Math.min(s.lv, lvNeed.length-1)] ?? Infinity;
  if (s.xp >= nextLvNeed){ s.lv = s.lv + 1; s.cp = s.hist.length; saveXP(s); awardManaOnLevelUp(); }
  updateXpUI();
}
function addExtraXPOnce(){
  if (reasonXpGiven) return;
  const s = ensureXP(); s.xp = (s.xp||0) + 1; saveXP(s); reasonXpGiven = true; updateXpUI();
}

/* ===== 理由チップ ===== */
function showReasonPanel(){
  reasonXpGiven = false;
  reasonPanel.innerHTML = "";
  for(const name of MASTER.reasons){
    const b = document.createElement("button");
    b.className = "reason-btn";
    b.type="button"; b.textContent = name;
    b.addEventListener("click", ()=> recordReason(name, b));
    reasonPanel.appendChild(b);
  }
  reasonPanel.style.display = "flex";
  setTimeout(()=>{ reasonPanel.style.display="none"; }, 10000);
}
async function recordReason(name, btn){
  if (!currentDeck) return;
  try{
    let ok=false;
    try{
      const res = await fetch(FN_REASON_ADD, { method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, reason: name }) });
      const j = await res.json().catch(()=> ({}));
      ok = res.ok && j?.ok!==false;
    }catch{}
    if(!ok){
      await sb.from("vote_reasons").insert({ deck_id: currentDeck.id, session_id: sid, reason: name });
      ok=true;
    }
    if(ok){ btn.classList.add("on"); addExtraXPOnce(); }
  }catch{}
}

// タイトル右のタグ表示（Edge→新→旧）
function tagChip(txt, kind){
  const el = document.createElement("span");
  el.className = "tagchip " + (kind || "free");
  el.textContent = txt;
  return el;
}

async function showDeckTags(deck_id){
  const box = $("#deckTags");
  box.innerHTML = "";
  if (!deck_id) return;

  // 0) Edge（CORS回避のため invoke 優先）
  try{
    const { data, error } = await sb.functions.invoke("get-tags", { body: { deck_id }});
    if (!error && data?.ok && data?.data){
      if (data.data.theme) box.appendChild(tagChip(data.data.theme, "theme"));
      for (const t of (data.data.tags||[]).slice(0,3)) box.appendChild(tagChip(t,"free"));
      return;
    }
  }catch{}

  // 1) 新スキーマ（decks.theme_key / deck_tags.tag_key）
  try{
    const [deckRow, tagRows] = await Promise.all([
      sb.from("decks").select("theme_key").eq("id", deck_id).maybeSingle(),
      sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id).limit(200)
    ]);

    const themeKey = deckRow?.data?.theme_key || null;
    const tagKeys  = (tagRows?.data||[]).map(r=>r?.tag_key).filter(Boolean);
    const allKeys  = [...new Set([themeKey, ...tagKeys].filter(Boolean))];

    if (allKeys.length){
      const { data: masters } = await sb
        .from("app_tags_master").select("key,label,kind").in("key", allKeys).limit(500);

      const byKey   = new Map((masters||[]).map(m => [m.key, m]));
      const labelOf = (k) => byKey.get(k)?.label || k;
      const kindOf  = (k) => byKey.get(k)?.kind  || "tag";

      let themeLabel = null, themeResolvedKey = null;

      if (themeKey){ themeLabel = labelOf(themeKey); themeResolvedKey = themeKey; }
      if (!themeLabel){
        const tk = tagKeys.find(k => kindOf(k)==="theme");
        if (tk){ themeLabel = labelOf(tk); themeResolvedKey = tk; }
      }
      if (!themeLabel){
        const tCand = tagKeys.find(k => (MASTER?.themes||[]).includes(labelOf(k)));
        if (tCand){ themeLabel = labelOf(tCand); themeResolvedKey = tCand; }
      }

      if (themeLabel) box.appendChild(tagChip(themeLabel, "theme"));

      const tagLabels = tagKeys
        .filter(k => k !== themeResolvedKey)
        .filter(k => kindOf(k)==="tag")
        .map(labelOf);

      for (const lab of [...new Set(tagLabels)].slice(0,3)){
        box.appendChild(tagChip(lab, "free"));
      }
      if (box.children.length) return;
    }
  }catch{}

  // 2) 旧スキーマ（deck_tags.theme / deck_tags.tags）
  try{
    const q = await sb.from("deck_tags").select("theme,tags").eq("deck_id", deck_id).maybeSingle();
    if (!q.error && (q.data?.theme || Array.isArray(q.data?.tags))){
      if (q.data.theme) box.appendChild(tagChip(q.data.theme, "theme"));
      for (const t of (Array.isArray(q.data.tags)? q.data.tags : []).slice(0,3)){
        box.appendChild(tagChip(t, "free"));
      }
    }
  }catch{}
}

/* ===== 表示 ===== */
async function showDeckByRow(row,{showResults=false}={}){
  currentDeck = row;
  reasonXpGiven = false;
  setEmbed(row.source_url);

  const id = toDeckId(row.source_url);
  if (id) history.replaceState(null, "", `${APP_URL}?deck=${id}`);

  const titleEl=document.querySelector('[data-deck-title]');
  titleEl.textContent = id ? `#${id}` : "#???????";
  titleEl.href = row.source_url;

  await showDeckTags(row.id);

  $("#results").style.display = showResults ? "flex":"none";
  await loadVotesAndRenderResults(showResults);
  await loadMyVote();

  clearInterval(autoNextTimer); autoNextTimer=null; autoNextHint.textContent="";
  nextBtn.classList.remove("pulse");

  try{ await safeLogImpression(row.id); }catch{}

  deckShownAtMs = performance.now();
}

/* ===== ランダム ===== */
async function loadRandomDeck(){
  const { data, error } = await sb.rpc("random_deck_for_session", { p_session: sid });
  if (error) { toast("読み込みエラー"); return; }
  const row = (Array.isArray(data) ? data[0] : null);
  if (!row) { toast("未回答のデッキがありません"); return; }
  await showDeckByRow(row,{showResults:false});
}

/* ===== 存在確認 ===== */
async function ensureDeckExists(url){
  const { data } = await sb.from("decks").select("id,source_url,deck_name,registered_at").eq("source_url", url).maybeSingle();
  if(data?.id) return data;
  const res = await fetch(FN_INGEST,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ url, session_id:sid }) });
  const j = await res.json().catch(()=> ({}));
  if(res.ok && j.ok){
    const { data: after } = await sb.from("decks").select("id,source_url,deck_name,registered_at").eq("source_url", url).maybeSingle();
    if(after?.id) return after;
  }
  throw new Error(j?.error || "登録に失敗しました");
}

/* ===== 投票 ===== */
let voting = false;
function setVoting(b){ voting=b; for(const btn of voteChips){ btn.disabled=b; } }

async function postVoteOnce(bracket, rtSec){
  const res = await fetch(FN_VOTE, {
    method: "POST",
    headers: { "Content-Type": "application/json","Authorization": "Bearer " + SUPABASE_ANON,"apikey": SUPABASE_ANON },
    body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, bracket, rt_sec: rtSec })
  });
  let ok = res.ok;
  try{ const j = await res.clone().json(); if (j && j.ok === false) ok = false; }catch{}
  return { ok, status: res.status };
}
async function postVoteWithRetry(bracket, rtSec){
  const retriable = new Set([429,409,500,502,503,504]);
  for (let i=0; i<2; i++){
    const { ok, status } = await postVoteOnce(bracket, rtSec);
    if (ok) return true;
    if (!retriable.has(status)) return false;
    await new Promise(r=>setTimeout(r, 250));
  }
  return false;
}
for (const el of document.querySelectorAll(".chip[data-vote]")){
  el.addEventListener("click", async (e)=>{
    if (!currentDeck || voting) return;
    const bracket = Number(e.currentTarget.dataset.vote);
    setVoting(true);
    try{
      const rtSec = Math.max(0, Math.round((performance.now() - deckShownAtMs)/1000));
      const done = await postVoteWithRetry(bracket, rtSec);
      if (!done){ toast("保存エラー。時間を空けて再試行してください。"); return; }

      const wasFirst = !hadMyVoteBefore;

      markMyVote(bracket);
      resultsEl.style.display="flex";
      nextBtn.classList.add("pulse");
      await loadVotesAndRenderResults(true);

      rtLabel.style.display="inline"; rtLabel.textContent = `${rtSec}sec`;
      pushHistory(rtSec);
      addXPIfFirstVote(rtSec, wasFirst);
      hadMyVoteBefore = true;

      // 理由チップ（10秒）
      reasonPanel.style.display="flex";
      showReasonPanel();

      // 次へカウントダウン
      let left = 10;
      autoNextHint.textContent = `${left}秒後に自動で次のデッキへ`;
      clearInterval(autoNextTimer);
      autoNextTimer = setInterval(()=>{
        left--;
        if(left<=0){ clearInterval(autoNextTimer); autoNextTimer=null; reasonPanel.style.display="none"; loadRandomDeck(); }
        else autoNextHint.textContent = `${left}秒後に自動で次のデッキへ`;
      }, 1000);
    }catch{ toast("保存エラーが発生しました。"); }
    finally{ setVoting(false); }
  });
}

/* ===== スキップ・次へ ===== */
async function onSkip(){
  try{
    if (currentDeck) {
      await fetch(FN_SKIP, { method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid }) });
    }
  }catch{}
  clearInterval(autoNextTimer); autoNextTimer=null;
  reasonPanel.style.display="none";
  await loadRandomDeck();
}
$("#skipBtn").addEventListener("click", onSkip);
nextBtn.addEventListener("click", ()=> { clearInterval(autoNextTimer); autoNextTimer=null; reasonPanel.style.display="none"; loadRandomDeck(); });

/* ===== 共有 ===== */
function currentDeckLink(){
  const id = currentDeck ? toDeckId(currentDeck.source_url) : null;
  return id ? `${APP_URL}?deck=${id}` : APP_URL;
}
function shareCurrentDeck(){
  const url = currentDeckLink();
  const tw = new URL("https://x.com/intent/tweet");
  tw.searchParams.set("text", "このデッキのブラケットは？ #みんなでブラケット診断");
  tw.searchParams.set("url", url);
  const w = window.open(tw.toString(), "_blank", "noopener,noreferrer");
  if (!w) { location.href = tw.toString(); }
}
$("#shareBtn").addEventListener("click", shareCurrentDeck);

/* ===== 通報 ===== */
$("#reportBtn").addEventListener("click", async ()=>{
  if(!currentDeck) return toast("デッキ未読込です");
  const btn = $("#reportBtn"); const orig = btn.textContent;
  btn.textContent="送信中…"; btn.classList.add("primary");
  try{
    const res = await fetch(FN_REPORT,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: currentDeck.id, session_id: sid, reason:"user_report_from_vote" }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j?.ok!==false){ btn.textContent="完了！"; setTimeout(()=>{ btn.textContent=orig; btn.classList.remove("primary"); onSkip(); }, 900); }
    else{ btn.textContent=orig; btn.classList.remove("primary"); toast("報告に失敗しました"); }
  }catch{ btn.textContent=orig; btn.classList.remove("primary"); toast("報告に失敗しました"); }
});

/* ===== シート ===== */
const sheet=$("#sheet"), backdrop=$("#backdrop");
function openSheet(){ sheet.style.display="flex"; backdrop.style.display="block"; }
function closeSheet(){ sheet.style.display="none"; backdrop.style.display="none"; }
$("#openSheet").addEventListener("click", openSheet);
$("#closeSheet").addEventListener("click", closeSheet);
backdrop.addEventListener("click", closeSheet);

/* ===== タブ ===== */
const tabs = document.querySelectorAll(".tab");
for(const t of tabs){
  t.addEventListener("click", ()=>{
    for(const x of tabs){ x.classList.remove("active"); x.setAttribute('aria-selected','false'); }
    t.classList.add("active"); t.setAttribute('aria-selected','true');
    const name=t.dataset.tab;
    $("#pane-reg").style.display = name==="reg" ? "block":"none";
    $("#pane-del").style.display = name==="del" ? "block":"none";
    $("#pane-mine").style.display= name==="mine"? "block":"none";
    if(name==="mine") loadMine();
  });
}

/* ===== 登録：タグUI 初期化（自由タグは最大3つ） ===== */
const regThemeSel = $("#regTheme");
const regTagBox = $("#regTagBox");
const regTagHint = $("#regTagHint");
const regChosen = new Set();
function chip(htmlText, on, onclick){
  const s = document.createElement("button");
  s.type="button";
  s.className = "chip-sel"+(on?" on":"");
  s.innerHTML = htmlText;
  s.addEventListener("click", ()=>{
    onclick?.(!s.classList.contains("on")); // 事前に可否チェック
    const canToggle = s.dataset._allow==="1";
    if(!canToggle) return;
    s.classList.toggle("on");
  });
  return s;
}
function updateTagLimitUI(){
  const selCnt = regChosen.size;
  regTagHint.textContent = `選択数: ${selCnt}/3`;
  const lock = selCnt >= 3;
  for(const b of Array.from(regTagBox.querySelectorAll(".chip-sel"))){
    if(!b.classList.contains("on")){
      b.disabled = lock; b.style.opacity = lock ? ".6" : "1";
    }else{
      b.disabled = false; b.style.opacity = "1";
    }
  }
}
function initRegTagsUI(){
  // テーマ
  regThemeSel.innerHTML = `<option value="">未選択</option>` + MASTER.themes.map(v=> `<option value="${v}">${v}</option>`).join("");
  // タグ
  regTagBox.innerHTML = ""; regChosen.clear();
  for(const t of MASTER.tags){
    const c = chip(t, false, (willOn)=> {
      // 事前チェック: 3つ超は不可
      if(willOn && regChosen.size>=3){ c.dataset._allow="0"; return; }
      c.dataset._allow="1";
      if(willOn) regChosen.add(t); else regChosen.delete(t);
      updateTagLimitUI();
    });
    regTagBox.appendChild(c);
  }
  updateTagLimitUI();
}
initRegTagsUI();

// タグ保存（Edge → 明示スキーマ分岐（new/old））
async function saveTagsForDeck(deck_id, themeLabel, tagLabels){
  if (!deck_id) return false;
  const tagsArr = Array.from(new Set(Array.isArray(tagLabels) ? tagLabels : [])).slice(0,3);

  // 0) Edge（動けば終了）
  try{
    const { data, error } = await sb.functions.invoke("set-tags", {
      body: { deck_id, theme: (themeLabel||null), tags: tagsArr }
    });
    if (!error && data?.ok !== false) return true;
  }catch{}

  const kind = await detectSchema();

  if (kind === "new"){
    try{
      // label→key 解決（無ければ label を key として採用）
      const { data: masters } = await sb.from("app_tags_master").select("key,label,kind").limit(2000);
      const toKey = (label, needKind)=> {
        const hit = (masters||[]).find(m => m.kind===needKind && (m.label===label || m.key===label));
        return hit?.key || label;
      };

      const tkey = themeLabel ? toKey(themeLabel, "theme") : null;
      const keys = tagsArr.map(l => toKey(l, "tag"));
      const rows = [
        ...(tkey ? [{ deck_id, tag_key: tkey, created_by_session: sid }] : []),
        ...keys.map(k => ({ deck_id, tag_key: k, created_by_session: sid }))
      ];

      // 失敗時に消えるのを避けるため、現在値を退避→削除→挿入（挿入失敗時は可能な範囲でロールバック）
      const before = await sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id);
      await sb.from("deck_tags").delete().eq("deck_id", deck_id);
      if (rows.length){
        const ins = await sb.from("deck_tags").insert(rows);
        if (ins.error){
          if (Array.isArray(before.data) && before.data.length){
            const rb = before.data.map(r=>({ deck_id, tag_key: r.tag_key, created_by_session: sid }));
            await sb.from("deck_tags").insert(rb);
          }
          throw ins.error;
        }
      }
      if (tkey) await sb.from("decks").update({ theme_key: tkey }).eq("id", deck_id);
      return true;
    }catch{}
  }else{
    try{
      await sb.from("deck_tags").delete().eq("deck_id", deck_id);
      await sb.from("deck_tags").insert({ deck_id, theme: (themeLabel||null), tags: tagsArr, created_by_session: sid });
      return true;
    }catch{}
  }

  return false;
}

/* ===== 登録 ===== */
$("#regBtn").addEventListener("click", async ()=>{
  const msg=$("#regMsg"); msg.textContent="";
  const v=$("#regUrl").value.trim(); const url=canonUrl(v); if(!url){ msg.textContent="URL形式が正しくありません。"; return; }
  msg.textContent="登録中...";
  try{
    const res = await fetch(FN_INGEST,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ url, session_id:sid }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j.ok){
      const row = await sb.from("decks").select("id,source_url,deck_name,registered_at").eq("source_url", url).maybeSingle();
      const deckRow = row?.data;
      if(deckRow?.id){
        const theme = regThemeSel.value || null;
        const tags  = [...regChosen];
        await saveTagsForDeck(deckRow.id, theme, tags);
        msg.textContent = "登録しました。";
        try{ await showDeckByRow(deckRow,{showResults:false}); }catch{}
      }else{
        msg.textContent = "登録は成功しましたがデッキを取得できませんでした。";
      }
      loadMine();
    }else{
      msg.textContent = `登録失敗: ${j?.error || res.statusText}`;
    }
  }catch{ msg.textContent="登録に失敗しました。"; }
});

/* ===== 通報タブ ===== */
$("#delBtn").addEventListener("click", async ()=>{
  const msg=$("#delMsg"); msg.textContent="";
  const v=$("#delUrl").value.trim(); const url=canonUrl(v); if(!url){ msg.textContent="URL形式が正しくありません。"; return; }
  const { data } = await sb.from("decks").select("id").eq("source_url", url).maybeSingle();
  if(!data?.id){ msg.textContent="まだ登録されていない可能性があります。"; return; }
  try{
    const res = await fetch(FN_REPORT,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id: data.id, session_id: sid, reason:"user_delete_request" }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j?.ok!==false){ msg.textContent="報告を受け付けました。ありがとうございました。"; }
    else{ msg.textContent=`報告に失敗しました: ${j?.error || res.statusText}`; }
  }catch{ msg.textContent="報告に失敗しました。"; }
});

/* ===== 自分の登録 ===== */
$("#reloadMine").addEventListener("click", ()=> loadMine());

async function openTagsModal(deck_id){
  // 取得したテーマ/タグを「ラベル」で保持する
  let theme = null, tags = [];

  // --- 0) Edge Functions（CORS回避：invokeを最優先） ---
  try{
    const { data, error } = await sb.functions.invoke("get-tags", { body: { deck_id } });
    if(!error && data){
      // 可能性のある返却形に広く対応
      const payload = data.data ?? data;
      const t = payload.theme ?? payload.theme_label ?? null;
      const arr = payload.tags  ?? payload.tag_labels ?? [];
      if (t) theme = String(t);
      if (Array.isArray(arr)) tags = arr.map(String);
    }
  }catch{}

  // --- 1) 旧スキーマ（deck_tags.theme/tags） ---
  if (theme===null && tags.length===0){
    try{
      const q = await sb.from("deck_tags").select("theme,tags").eq("deck_id", deck_id).maybeSingle();
      if (!q.error && q.data){
        theme = q.data.theme || null;
        tags  = Array.isArray(q.data.tags) ? q.data.tags : [];
      }
    }catch{}
  }

  // --- 2) 新スキーマ（decks.theme_key / deck_tags.tag_key） ---
  if (theme===null && tags.length===0){
    try{
      const [deckRow, tagRows] = await Promise.all([
        sb.from("decks").select("theme_key").eq("id", deck_id).maybeSingle(),
        sb.from("deck_tags").select("tag_key").eq("deck_id", deck_id).limit(100)
      ]);
      const tkey  = deckRow?.data?.theme_key || null;
      const tkeys = (tagRows?.data||[]).map(r=>r?.tag_key).filter(Boolean);
      const all   = [...new Set([tkey, ...tkeys].filter(Boolean))];
      if (all.length){
        const { data: masters } = await sb
          .from("app_tags_master").select("key,label,kind").in("key", all).limit(500);

        const toLabel = (k)=> (masters||[]).find(m=>m.key===k)?.label || k;

        // テーマは theme_key を優先、なければ tag_key に kind===theme があるかチェック
        theme = tkey ? toLabel(tkey) : null;

        if (!theme){
          const tFromTags = (masters||[]).find(m => m.kind==="theme" && tkeys.includes(m.key));
          if (tFromTags) theme = tFromTags.label || tFromTags.key;
        }

        // 自由タグは theme とかぶるキーを除外
        const themeKeyResolved = (masters||[]).find(m => (m.label===theme || m.key===theme))?.key ?? null;
        tags = tkeys
          .filter(k => k !== themeKeyResolved)
          .map(toLabel);
      }
    }catch{}
  }

  // ===== UI =====
  const body = document.createElement("div");

  const cap1 = Object.assign(document.createElement("div"), { textContent:"デッキの狙い（1つ）" });
  cap1.className = "note"; cap1.style.margin = "6px 0 4px";

  const sel = document.createElement("select");
  // マスターに無いラベルでも選べるように、先頭に「未選択」、ついでに現在の値を先に差し込む
  sel.innerHTML = `<option value="">未選択</option>`;
  if (theme && !MASTER.themes.includes(theme)){
    sel.insertAdjacentHTML("beforeend", `<option value="${theme}">${theme}</option>`);
  }
  sel.insertAdjacentHTML("beforeend", MASTER.themes.map(v=> `<option value="${v}">${v}</option>`).join(""));

  // “ラベル一致” で確実に選択するヘルパ
  const choose = (selectEl, valueOrText) => {
    const want = String(valueOrText ?? "").trim();
    if (!want){ selectEl.value=""; return; }
    selectEl.value = want;
    if (selectEl.value !== want){
      const opt = Array.from(selectEl.options).find(o => String(o.textContent).trim() === want);
      if (opt){ opt.selected = true; }
    }
  };
  choose(sel, theme);   // ← 既存テーマを確実に選択

  body.append(cap1, sel);

  // タグ（最大3つ）
  const cap2 = Object.assign(document.createElement("div"), { textContent:"タグ（最大3つ）" });
  cap2.className="note"; cap2.style.margin = "10px 0 4px";

  const box = document.createElement("div"); box.className="row";
  const chosen = new Set((Array.isArray(tags)? tags: []).map(String));

  function refreshLock(){
    const lock = chosen.size >= 3;
    for(const b of box.querySelectorAll(".chip-sel")){
      if(!b.classList.contains("on")){ b.disabled = lock; b.style.opacity = lock ? ".6" : "1"; }
    }
  }

  // マスターに無いタグも最初から選べるようにする
  const tagUniverse = [...new Set([ ...MASTER.tags, ...chosen ])];
  for(const t of tagUniverse){
    const b = document.createElement("button");
    b.type="button";
    b.className = "chip-sel" + (chosen.has(t) ? " on" : "");
    b.textContent = t;
    b.addEventListener("click", ()=>{
      if(!b.classList.contains("on") && chosen.size>=3) return;
      b.classList.toggle("on");
      if(b.classList.contains("on")) chosen.add(t); else chosen.delete(t);
      refreshLock();
    });
    box.appendChild(b);
  }
  refreshLock();
  body.append(cap2, box);

  openModal("タグ編集", body, true, async ()=>{
    const ok = await saveTagsForDeck(deck_id, (sel.value||null), [...chosen]);
    if(ok){ toast("保存しました"); closeModal(); await showDeckTags(deck_id); }
    else{ toast("保存に失敗しました"); }
  });
}


async function openReasonsModal(deck_id){
  let rows = [];

  // --- 0) Edge Functions（invoke優先。返却形の揺れに対応） ---
  try{
    const { data, error } = await sb.functions.invoke("reason-sum", { body: { deck_id, limit: 50 } });
    if (!error && data){
      const payload = data.data ?? data.reasons ?? data;
      if (Array.isArray(payload)){
        // 文字列配列 or {reason,cnt}[] の両対応
        if (typeof payload[0] === "string"){
          const m = new Map();
          for(const r of payload){ m.set(r, (m.get(r)||0)+1); }
          rows = [...m.entries()].map(([reason,cnt])=>({reason, cnt}));
        }else{
          rows = payload.map(x => ({ reason: String(x.reason ?? x.name ?? "その他"), cnt: Number(x.cnt ?? x.count ?? 0) }));
        }
      }
    }
  }catch{}

  // --- 1) vote_reasons 直読 → JS集計 ---
  if (rows.length === 0){
    try{
      const { data: list, error } = await sb
        .from("vote_reasons")
        .select("reason")
        .eq("deck_id", deck_id)
        .limit(10000);
      if(!error && Array.isArray(list)){
        const m = new Map();
        for(const r of list){ const k=(r?.reason||"その他"); m.set(k,(m.get(k)||0)+1); }
        rows = [...m.entries()].map(([reason,cnt])=>({reason,cnt})).sort((a,b)=>b.cnt-a.cnt).slice(0,50);
      }
    }catch{}
  }

  // --- 2) RPC フォールバック ---
  if (rows.length === 0){
    try{
      const { data, error } = await sb.rpc("reason_sum_by_deck", { p_deck: deck_id, p_limit: 50 });
      if(!error && Array.isArray(data)){
        rows = data.map(r => ({ reason: r.reason, cnt: Number(r.cnt)||0 })).sort((a,b)=>b.cnt-a.cnt);
      }
    }catch{}
  }

  // ===== 表示 =====
  const body = document.createElement("div");
  if(rows.length===0){
    body.textContent = "まだ理由がありません。";
  }else{
    for(const r of rows){
      const line = document.createElement("div");
      line.style.display="flex";
      line.style.justifyContent="space-between";
      line.style.padding="4px 0";
      line.innerHTML = `<span>${r.reason}</span><b>${r.cnt}</b>`;
      body.appendChild(line);
    }
  }
  openModal("投票理由（上位）", body, false, null);
}

async function loadMine(){
  const listEl=$("#mineList");
  listEl.innerHTML="読み込み中…";
  const { data, error } = await sb.from("decks")
    .select("id,source_url,deck_name,created_at")
    .eq("created_by_session", sid)
    .order("created_at",{ascending:false})
    .limit(50);
  if(error){ listEl.textContent="読み込みエラー"; return; }
  if(!data || data.length===0){ listEl.textContent="まだ登録がありません。"; return; }

  // 集計（rt_sec>=5 or null）
  const ids = data.map(d=>d.id);
  const countsMap = {};
  try{
    if(ids.length){
      const { data: agg, error: aggErr } = await sb.rpc('labels_counts_by_deck_many', { p_decks: ids, p_min_rt: 5, p_include_null:true });
      if(!aggErr && Array.isArray(agg)){
        for(const r of agg){
          const arr = countsMap[r.deck_id] || (countsMap[r.deck_id]=[0,0,0,0]);
          const i = (r.bracket|0) - 1; if(i>=0 && i<4) arr[i] = Number(r.cnt) || 0;
        }
      }
    }
  }catch{}
  if(Object.keys(countsMap).length===0){
    for(const d of data){
      try{
        const { data: rows } = await sb.from("labels").select("bracket,rt_sec").eq("deck_id", d.id).limit(10000);
        const arr=[0,0,0,0];
        for(const r of (rows||[])){ if(passRtFilter(r.rt_sec)){ const i=(r.bracket|0)-1; if(i>=0&&i<4) arr[i]++; } }
        countsMap[d.id]=arr;
      }catch{ countsMap[d.id]=[0,0,0,0]; }
    }
  }

  listEl.innerHTML="";
  for(const d of data){
    const idNum = toDeckId(d.source_url) || d.id;
    const item=document.createElement("div"); item.className="item";

    const a=document.createElement("a");
    a.href=d.source_url; a.target="_blank"; a.rel="noopener noreferrer"; a.textContent = idNum;

    const wrap=document.createElement("div"); wrap.className="mini-wrap";
    const [c1,c2,c3,c4] = countsMap[d.id] || [0,0,0,0];
    wrap.append( makeMiniBar(c1,c2,c3,c4) );

    const show=document.createElement("button"); show.className="small-btn"; show.textContent="表示"; show.type="button";
    show.addEventListener("click", async ()=> {
      const row = await sb.from("decks").select("id,source_url,deck_name,registered_at").eq("id", d.id).maybeSingle();
      if(row.data) await showDeckByRow(row.data,{showResults:false});
      closeSheet();
    });

    const reasonBtn=document.createElement("button"); reasonBtn.className="small-btn"; reasonBtn.textContent="投票理由"; reasonBtn.type="button";
    reasonBtn.addEventListener("click", ()=> openReasonsModal(d.id));

    const tagBtn=document.createElement("button"); tagBtn.className="small-btn"; tagBtn.textContent="タグ編集"; tagBtn.type="button";
    tagBtn.addEventListener("click", ()=> openTagsModal(d.id));

    const del=document.createElement("button"); del.className="small-btn"; del.textContent="削除"; del.type="button";
    del.addEventListener("click", ()=> deleteOwn(d.id, item));

    item.append(a, wrap, show, reasonBtn, tagBtn, del);
    listEl.appendChild(item);
  }
}

/* 削除フォールバック */
async function deleteOwn(deck_id, node){
  if(!confirm("この登録を削除しますか？（投票/通報も削除されます）")) return;

  try{
    const { data, error } = await sb.functions.invoke("delete-own-deck", { body: { deck_id, session_id: sid } });
    if(!error && (data?.ok!==false)){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  try{
    const res = await fetch(FN_DELETE_OWN,{ method:"POST", headers:{ "Content-Type":"application/json","Authorization":"Bearer "+SUPABASE_ANON,"apikey":SUPABASE_ANON }, body: JSON.stringify({ deck_id, session_id: sid }) });
    const j = await res.json().catch(()=> ({}));
    if(res.ok && j?.ok){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  try{
    const r = await sb.rpc('delete_own_deck', { p_deck: deck_id, p_session: sid });
    if(!r.error){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  try{
    const d = await sb.from("decks").delete().eq("id", deck_id).eq("created_by_session", sid);
    if(!d.error){ toast("削除しました"); if(node) node.remove(); if(currentDeck?.id===deck_id) loadRandomDeck(); return; }
  }catch{}

  toast("削除に失敗しました。");
}

/* ===== 起動 ===== */
updateXpUI();
const paramDeck = new URLSearchParams(location.search).get("deck");
if (paramDeck) {
  const url = canonUrl(paramDeck);
  if (url) {
    try { const row = await ensureDeckExists(url); await showDeckByRow(row, { showResults: true }); }
    catch { await loadRandomDeck(); }
  } else { await loadRandomDeck(); }
} else { await loadRandomDeck(); }

// キーボードショートカット
window.addEventListener('keydown', (e)=>{
  const tag = document.activeElement?.tagName;
  if (tag === 'INPUT' || tag === 'TEXTAREA') return;
  if (['1','2','3','4'].includes(e.key)) {
    document.querySelector(`.chip[data-vote="${e.key}"]`)?.click();
  } else if (e.key.toLowerCase()==='s') {
    document.getElementById('skipBtn')?.click();
  } else if (e.key.toLowerCase()==='n') {
    document.getElementById('nextBtn')?.click();
  }
});

// type保険
for (const b of document.querySelectorAll('button:not([type])')) b.setAttribute('type','button');

// ミニグラフ
function makeMiniBar(c1,c2,c3,c4){
  const total = Math.max(0, (c1|0)+(c2|0)+(c3|0)+(c4|0));
  const per = total ? [c1/total*100,c2/total*100,c3/total*100,c4/total*100] : [0,0,0,0];
  const bar = document.createElement('div'); bar.className='mini-bar';
  const s1=document.createElement('div'); s1.className='mini-seg b1'; s1.style.left='0%'; s1.style.width=per[0]+'%';
  const s2=document.createElement('div'); s2.className='mini-seg b2'; s2.style.left=per[0]+'%'; s2.style.width=per[1]+'%';
  const s3=document.createElement('div'); s3.className='mini-seg b3'; s3.style.left=(per[0]+per[1])+'%'; s3.style.width=per[2]+'%';
  const s4=document.createElement('div'); s4.className='mini-seg b4'; s4.style.left=(per[0]+per[1]+per[2])+'%'; s4.style.width=per[3]+'%';
  const ov=document.createElement('div'); ov.className='mini-overlay';
  const label = total ? `1 ${Math.round(per[0])}% ・ 2 ${Math.round(per[1])}% ・ 3 ${Math.round(per[2])}% ・ 4 ${Math.round(per[3])}%` : '投票なし';
  ov.textContent = label; bar.title = label;
  bar.append(s1,s2,s3,s4,ov);
  return bar;
}
</script>
</body>
</html>
